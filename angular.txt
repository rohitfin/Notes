
https://v2.angular.io/docs/ts/latest/guide/template-syntax.html#!#template-input-variables

=> npm install -g @angular/cli@latest 
=> ng new myProjectName -- create new project
=> ng serve -- start (npm start)
=> npm ng build => build
=> CTR + C -- stop
=> ng generate component xyz -- generate component
=> ng generate module ModuleName --route ModuleName --module app.module => create module with routing and add module path on app.module
=> ng g pipe pipeName
=> routing and navigation -- on change of URL load the component - <router-outlet></router-outlet>
=> service -- access from any where. to share a data between component to component.
=> http -- ajax
=> Change port => ng serve --open --port=3200 -> between 1024 to 65535

---code---
=>  npm i jQuery / npm i bootstrap@3 => install bootstrap, ngBootstrap and jquery 

=> component => ng generate component firstComponent || ng g c firstComponent   (ng g c NewCompo --spec=false)
    ts => decorator- @component
    selector => 'my-page', '.my-page', '[my-page]'
    use by => <my-page>, <div class="my-page">, <div my-page>

  => Standalone component - ng g c componentName --Standalone 
      { path: 'standalone', loadComponent: () => import('./standalone/standalone.component').then(m => m.StandaloneComponent) },

  => component with routing and module.
    ng g m [myModule_name] --route [myRoute_path_name] --module [routing_module_name]

  => Module with routing
    ng g m ModuleName --routing=true  

=> routing 
  route module / lazy loading
  ng generate module ModuleName --route ModuleName --module app.module

  ng generate module app-routing --flat --module=app (creating app.routing file)

  app-routing.ts
  { path: 'moduleOne', loadChildren: () => import('./module-one/module-one.module').then(m => m.ModuleOneModule) }

  <a routerLink="blog"> Blog </a> 
  <a [routerLink]="['/blog'], Id"> Blog One </a> 
  <router-outlet></router-outlet>
 
  { path: '**', component: HomeComponent },
  { path: '',   redirectTo: '', pathMatch: 'full', component: HomeComponent }
  { path: '',   redirectTo: 'HomeComponent', pathMatch: 'full' }

=> data binding 
  {{data}}  --> using interpolation to value binding
  [property]="data" --> attribute Binding to DOM  
  (click)="save()" --> Event Binding 
  [(ngModel)]="data" --> two way data biding [FormsModule] 
  
  <button [disabled]="!isVisible" [style.color]="textColor" [class.active]="isActive" (click)="save()"> Save </button>

=> for loop
  *ngFor="let value of arrayName;let i=index"  
  
=> Api Calls - import http 
    app-module =>  import { HttpClientModule  } from '@angular/common/http';
    myService => import { HttpClient } from '@angular/common/http';
      constructor(private http: HttpClient) { }

      const headers = new HttpHeaders({
        'Content-Type': 'application/json',
        'Authorization': 'Bearer your-token-here'
      });

      getData(data: any): Observable<any> {
        return this.http.post<any>(api, data, { headers }); // HTTP POST request
      }

----------------------------------------------
=> NGRX 
  NGRX is a state management library for Angular applications. It helps manage and share data across
   components efficiently using Redux principles.

  the application state is stored in a central store. component can dispatched the actions to update the
  states and the state changes are handled by pure functions called reducers. 
  NGRX offers ability to use side effects through effects, which allow for asynchronous operations such
  as making api calls.
  Selectors are function that extract specific pieces of state from the overall application state. 

  Uni direction data flow, Manage asynchronous operations, consistent data flow, centralized store.

  Action -> actions are dispatched to trigger state changes.
  Reducer -> Reducers is pure function that specify how the application state should change in response 
    to dispatched actions. They take the current state and dispatched action an input and retun new
    state.

  Selectors -> To access the update state, we can use selectors.
  Once an action is dispatched, the reducer update the state in response to that action. to access
  to the update state, we can use selectors. Selectors are utility function that allow us to effectively 
  access and retrieve specific pieces of state form the centralized store.

  Effects ->


-----------------------------------------------
=> Important Points 
  => domSanitizer html =>  ensure that any content inserted into the DOM does not contain harmful code.
        this.title = this.domSanitizer.bypassSecurityTrustHtml('heading');
      <div [innerHTML] = "title"></div>

      <div [style]="safeStyle">Styled Text</div>
      unsafeStyle: string = 'background-color: red; color: green;';
      safeStyle: SafeStyle;
      this.safeStyle = this.domSanitizer.bypassSecurityTrustStyle(this.unsafeStyle);

  => loop 
    *ngFor="let dummy of ' '.repeat(4).split(''), let x = index

  => Meta tags  (https://sreyaj.dev/dynamically-update-title-and-meta-tags-angular)
    import { Meta, Title } from '@angular/platform-browser'
    constructor(
      private meta: Meta,
      private title: Title) { }
    ngOnInit(): void {
      this.title.setTitle("xxxxxxx")
      this.meta.addTags([
        { name: 'keywords', content: 'xxxxxx' },
        { name: 'description', content: 'xxxxx' },
      ])
    }

  => Scroll 
  infinite-scroll [infiniteScrollDistance]= "5" [infiniteScrollThrottle]="150" (scrolled)="onScrollDown()"
  onScrollDown(ev?:any) { console.log("scrolled down!!", ev);  }

  => Update 
    update angular globally, update typescript, legacy peer make true, npm i, ng g environments

-----------------------------------------------

=> Theory with example

  * Adding Bootstrap styles links on the angular.json file On Architect / build section
  * For ngBootstrap -> import styles on style.css file
  * for icon -> import icon file on style.css file.
  * How to create angular application
      It required 3 things node, npm, angular cli.
      ng new applicationName

  * Which File Executes First in Angular?
    First it goes to the angular.json file, It loads up main.ts (first file that executes) and read its content.
    index.html, main.ts, app-module(Know all about component in this file).
    Angular runs main.ts → bootstraps AppModule.
    AppModule declares AppComponent.
    AppComponent is rendered inside <app-root>.

    
    => e2e => end to end test, automate test 
    
    => node modules => all third party libraries, not deployed our server
    
    => environment => store configuration setting
    
    => main.ts => starting point our application
    
    => polyfills.ts => feel the gap between browser and the javascript version to run the code in angular
    
    => test.ts => setting our environment
    
    => .editorconfig => all developer team have same setting
    
    => .gitignore => managing our code 
    
    => karma.config => test runner of javascript code 
    
    => protractor.conf.js => running tool for e2e.
    
    => tsconfig.json => tells the typescript compiler how to compile your angular project.
      - compilerOptions
      - Target - specifies the javascript version
      - module - Defines the module system
      - sourceMap - enables generating of source maps for debugging
      - experimentalDecorators - Required for angular decorators like @component
      - angularCompilerOptions
    
    => tslint.json => static annalistic typescript code
    
    => vendor.bundle.js => third party libraries
    
    => package.json => What version is required. It is the primary file that manages your project’s dependencies, scripts, metadata, and configuration.
      name - name for the angular app.
      version - version of your app (used for versioning, deployments, etc.)
      script - custom npm commands like ng serve, ng build 
      dependencies - Packages required for the app to run in production
      devDependencies - Packages needed only for development and testing
      private - if set to true, prevents accidental publishing to npm.
    
    => package-lock.json => Locks exact versions of dependencies to ensure consistency.
    everyone have exact versions of dependencies.
    It locks the exact version of each dependency and its sub-dependencies to ensure consistent installs across all environments.
    If you’re cloning a project or setting it up in a new environment, running npm install will refer to the package-lock.json to ensure you get the same dependencies as the original developer.
    
    angular.json =>  configure project-specific settings like source files, build output paths, assets, styles, scripts,
     and build process for different environments (e.g., production, development).
  
    => Environment configuration
      environment configuration allows you to define different settings for different build environments like development, production, staging, etc.

      To change values like API URLs, feature flags, logging behavior, etc. without modifying your main source code.
      For example:
      Dev: https://dev-api.example.com
      Prod: https://api.example.com
      
  stylesheets compile => all stylesheets compile into javascript.


  => ng serve : Serve the app for development, Compiles, serves the app on a local server, watches for changes.
    compiles the app, serves it on a local server, and watches for changes to recompile and reload the app automatically.
    Initialize the angular cli, compile the application, watch for file changes, serve, live reload

  => ng build : Build the app for production or deployment
    compiles, bundles, and optimizes your application for deployment. It creates the final output that is placed in the dist/ folder and ready to be uploaded to a server. 
    Initialize the build process - check angular.json file for build setting like ng build --prod

    * compile typescript - typescript compiled into javascript (main.ts)
    * bundle the code - use webpack to bundle application into a smaller set of files
    * file replacement - check angular.json file for building for production, replace file like environment.ts file with the environment.prod.ts file
    * output the file - Optimized file are placed in the dist folder. includes javascript bundle (main.js, runtime.js), html file (index.html), css file, assets (images, fonts, etc)
    * Production Optimization - When building for production (ng build --prod), Angular will perform additional optimizations:
      - Minify javascript and css, 
      - tree shaking (removes unused code),
      - Ahead of time (AOT) compilation - pre-compiles for better performance
      - Enable caching - Hashes are added to filenames to help with caching.

  => Angular 
    Angular is javascript framework. Angular is a component based single page application that is written in typescript. It is maintained by google.

  => Directive - ng g directive directive-name
    Directive use for DOM manipulation.Directives are classes that add additional behavior to elements. 
    With directive we can manage forms, lists, styles and what user see. With Directive we should tell DOM element how should behave or look like.

    Components =>	Used with a template. This type of directive is the most common directive type.

    Attribute directives =>	Change the appearance or behavior of an element, component, or another directive. with NgClass, NgStyle and NgModel

    Structural directives =>	Change the structure on the DOM by adding or removing DOM elements. with the help of NgFor, NgIf and NgSwitch (common module)

    => Custom Directives
      ng g directive CustomDirective
      2 files created and update in app.module file
      CustomDirective.ts file => import { ElementRef } from '@angular/core';
        class CustomDirectiveWork {
          constructor(private el: ElementRef,private renderer : Renderer2) {
            el.nativeElement.style.color = "red"    (with nativeElement we can access JavaScript DOM elements)
          }
        }
        <div CustomDirectiveWork> check directive work </div>
        
    => Renderer2 
      DOM manipulating without accessing the DOM directly and that is by using renderer2 class.
      Renderer2 allow us to manipulate the DOM without accessing the DOM elements directly, by proving a layer of 
      abstraction between the DOM element and the component code.

        constructor( private element: ElementRef, private renderer: Renderer2 ){ }
        ngOnInit(){ this.renderer.setStyle(this.element.nativeElement, 'backgroundColor', 'black'); }

  => Host binding , Host listener 
    When we create custom directive and binding element in our directive with the use of host binding and 
    to continuously listening event so we use host listener.
    with the help of @HostListener we addClass and removeClass, mouseenter, mouseout event.
    
    @HostListener is like saying: "When someone interacts with this element (like clicking), run this function."

    @HostBinding is like telling Angular: "Please set this class/style/property on the HTML element I’m attached to."

    @HostListener('mouseenter') OnMoseEnter(){
      this.renderer.addClass(this.element.nativeElement, 'product-highlight');
    }
    
    @HostBinding('style.background') backgroudClr: string = 'black';
    @HostBinding('style.color') textColor: string = 'red';

  => One Way binding => use for Data exchange
    One way binding data flow one directional. Means ts file to html. When we change on html file it will
     not change on ts. We can get the data with template binding or event binding

  => Two way binding => use for Data exchange --> [(ngModel)]
    Two way binding data flow two directional. Means when we change on ts file, it will change on html file and when 
    change on html file, it also change on ts file. We can get the data with [(ngModel)].

  => Input decorator  - pass property from parent to child
          parent
            <app-child [property]="expression"></app-child>
            expression = 'Enter your message';

          child
            import Input decorator.
            @Input() property:any;
            {{ property }}

  => Output decorator, EventEmitter
      Some time we pass data or action child component to parent component. we can create event by using 
      "EventEmitter" and we can raise that event by  using predefined the method "emit()".

      parent.html
        <app-child (onParentClickEvent)="func($event)"></app-child>
      parent.ts 
        func(eventValue){ condition; }

      child.ts
        import output decorator
        @Output() onParentClickEvent : EventEmitter = new EventEmitter();

        clickEvent(value){
          this.onParentClickEvent.emit(value);
        }

  => Template reference (#)
      A template reference variable is a variable to store a reference to a DOM elements, component or directive
       on which is used.
      
      <input type="text" #inputText />
      <button (click)='onClickGet(inputText);'>Click</button>

      onClickGet(inputEl: HTMLInputElement){
        console.log(inputEl);
      }

  => @viewChild
    Parent component access all the methods and properties form child components. Single instance
    parent.ts 
      import viewChild
      @viewChild("referenceVariableName") variableName: ChildComponentName;
      func(){
        this.variableName ----> access all the method and properties
      }
    parent.html 
      <app-child #referenceVariableName ></app-child>  

      or
      the viewChild decorator is used to query and get a reference of the DOM element in the component.
       It returns the first matching element based on the selector. It take 2 argument. second argument is Optional.
        1. read: Use it to read the different token form the query elements.
        2. static: Determines when the  query is resolved.
          - True is when query is initialized (before the first change detection) for the first time.
          - False if you want it to resolved after every change detection. 
            (it will only get initialzed when the change detection cycle runs )
            ex. @viewChild('inputText', {static: true});
      
      Child component 
      <input type="text" #inputText />
      <button (click)='onClickGet();'>Click</button>

      @viewChild('inputText') inputEl: ElementRef; 
      // take two argument, first selector Element or selector component we can pass and second optional object.
      onClickGet(){
        console.log(this.inputEl.navtiveElement.value);
      }

  => @viewChildren 
      The viewChildren decorator is used to get a reference to the list of DOM element form the view template 
      in the component class. It returns all the matching elements.

      Import "QueryList" and convert "QueryList to Array".

    parent.ts 
      import viewChild and QueryList 
      @viewChild("referenceVariableName") variableName: QueryList<ChildComponentName>;
      func(){
        var getAll = this.variableName.toArray();
      }
    parent.html 
      <app-child #referenceVariableName ></app-child> 

    OR
      Child component 
      <input type="text" #inputText />
      <input type="email" #inputText />
      <input type="number" #inputText />
      <button (click)='onClickGet();'>Click</button>

      @viewChildren('inputText') inputEls: QueryList<ElementRef>; 
      // take two argument, first selector Element and second optional object.
      onClickGet(){
        this.inputEls.forEach((el)=>{
        console.log(el.navtiveElement.value);
        })
      }

  => ng-container    
    ng-container is a special angular element. It doesn't create any extra element. When we are using two directives
    then it comes in the picture. When we use *ngIf and *ngFor then we use ng-container.

  => ng-content and contentChild
    ng-content =>  is a powerful tool for content projection in Angular. It enables you to create flexible, reusable 
    components that can accept dynamic content from their parent components.

    parent.html 
      <app-child>
        <h1>Hello</h1>
        <p #para>How are you?</p>
      </app-child>

    child.html
      <section>
        <h2>heading</h2>
        <ng-content></ng-content>
        <p>Data is coming form parent component</p>
      </section>  

    child.ts
    @contentChild('para') paraEl: ElementRef;
    click(){
      console.log(this.paraEl.nativeElement);  
    }

  => Component 
    component is basic ui block of code that represent the specific view.
    Components are building block of our application that are use to develop specific part of project. for example header, footer, body part. When we create component we have to register it inside our module file. Its creates 4 file html, css, ts and spec.ts file.

      ts => decorator- @component
      selector => 'my-page', '.my-page', '[my-page]'
      use by => <my-page>, <div class="my-page">, <div my-page>

    => Standalone component
      Standalone component is not depend to anyone it will work independently. While creating standalone component its adds one flag that is 'standalone true'. If dependencies is required to import like commonModule on the component level but not on the module level. Most important point is standalone component no need to import on app.module file.

        ng g c componentName --standalone 
        standalone component work same as module component (lazy loading).

    => Dump component
        Dump components are primarily concerned with the presentation and display data. They are also known as 'presentational components' or 'view component'.
        Dump component received data from their parent component. They dont have dependencies on service to perform complex business logic.

    => Smart Component 
        Smart components are responsible for managing the application's state and business logic. They often interact with services to fetch or manipulate data.

  => life cycle hook 
      In angular, every component has lifecycle. Angular create and render there components and also 
      destroy them before removing from the DOM. This is achieve with the help of lifecycle hook.
      - there are total 8 types of hooks but most used hooks are 4, 
      Angular automatically executes some method in our component class at each milestone to the life cycle.
      these are called lifecycle hooks.

        - Once the constructor phase is done now the lifecycle method get started.

      1.  ngOnChanges 
        get execute every time input bound properties of the component changes.
        Execute automatically when we have received one or more values into input properties. that are decorated by @Input decorator. 
        It will not execute when there are no input properties.

      2. OnInit 
        ngOnInit is an angular life cycle hook. Its called by angular after the constructor and after angular has finished initializing the component's properties.
        we can make api calls in ngOnInit.

        Execute automatically after loading the properties of the components. this called after ngOnChanges. used to perform actually business logic.
        Use to call service to get initial data from the database.

      3. ngDoCheck 
        Execute every time when change detection process start in the component.
        Execute when an event occur, before change "detection process". Use to identify whether change detection process occur or not.
        Use for third party control.
      
      4. ngAfterContentInit
        Execute only once in a lifetime of the components after initializing the content that is supply by the parent component and rendered
        using "ng-content" tag. 

      5. ngAfterContentChecked 
        Execute every time after completion of change detection process to the content.

      6. ngAfterViewInit 
        Execute only once after initializing all the elements in the template of the component.

      7. ngAfterViewChecked 
        Execute every time after completion fo change detection process of the template. 

      8. ngOnDestroy 
        Execute before destroying (deleting) the component object deleted from memory. [ when the route has changed. ]

      Injector, provider, how to get service? => services get injected inside our component

  => constructor
     The constructor is a standard Typescript class constructor. The constructor is automatically called when a new instance of the class is created.
    Angular uses the constructor to inject services or dependencies into your component or service.
     It’s mainly used to set up things or to get ready-to-use services (like HTTP or custom services).

  => Module 
    Module is collection of components, directives, pipes and services.
    Module use to organize the component and directives, pipes.
    Module mainly use to create meaning-full groups of component that are related to specific user, part of the project or achieve 
    some goal.
    eg: login component, register component, my profile component
    Module load only selected/ necessary components.

    export that file on module -> import on app.module.ts file -> then use those components

    ng g module moduleName
    or
    ng generate module ModuleName --route
    or
    ng generate module ModuleName --route ModuleName --module app.module

  => route
      routing is nothing but navigating one page to another page.
      basic routing, child routing, module routing, lazy loading, redirect 404, and get route values.

    => route module / lazy loading

      lazy loading a component means loading it only when it's needed, not when the app starts. This improves performance, especially for large apps.
      
      when we defined routing on a specific module then we call routing module.
      with route module load only necessary route or components.

      routing module component ko import krna pdta hai app.module me. (import krne pr lazy loading nhi rah jata hai.)

      => Multiple Router Outlets
        We can have multiple router Outlets by default there is always/"at least" 1 router outlet in app.component.html file 
        When we don't provide any name for router-outlet it becomes primary 
        There should be only 1 primary. We can define multiple router outlets by giving name to them 
        That's why we call them "named" router outlets. we can give any name we want - give meaningful names 
        In routing module - if you don't define outlet - it means its primary. It will NOT show if you directly access it in the URL 
        Syntax should be like this  - http://localhost:4200/<primary-route>( <routerOutletName> : <secondaryPath> )

      => HashLocationStrategy 
        Hands-on examples for PathLocationStrategy 
        - Default behavior of Angular apps 

        Hands-on examples for HashLocationStrategy
          - We need to import HashLocationStrategy from @angular/core 
          - Add it to Providers array 
          - Angular will start loading our URLs using # 
            index.html/#/loans/add 

      => Parametrized Routes - Dynamic Routes - the route parameter are the dynamic part of the route whose value can change. These parameters provide a way to pass extra information to a given route. 
        - We can send dynamic data or parameters to our routes. Those are visible in the url.
        - URLs will look something like this - http://localhost.com/user/10
        - While writing dynamic URLs/Params - make sure you write :(colon) for dynamic data means it can be string, integer. 
            { path: 'product/:id', component: ProductComponent }
        - Import the ActivatedRoute class 
        - We can read the value in the component class 
            - Create an object in constructor 
                constructor(private activatedRoute: ActivatedRoute){
                  this.activatedRoute.params.subscribe( res => {
                    console.log(res) // its print id means dynamic url 
                  })
                }
        or 
          { path: 'NameComponent/:itemId', component: NameComponent },
          var urlLastVal = this.route.snapshot.params["itemId"];
          var urlLastVal = this.route.snapshot.paramMap.get('itemId'); // this approach is not good when redirecting on same page only changing parameterID.
          
          this.route.paramMap.subscribe((params: ParamMap)=>{
             var urlLastVal = params.get('itemId');
          })

      => Router link 
          when ever we want to create a link we use routerLink.
          router link can be static or dynamic in nature.
          We DO NOT have to put "/" in variables in routerLink

          ex: <a routerLink="user" [routerLinkActive]=" 'active' " [routerLinkActiveOptions]=" { exact: true} ">User Page</a>
          ex: <a [routerLink]=" 'user' ">User Page</a>
          ex: <a [routerLink]=" ['user'] ">User Page</a>
          ex:  adding dynamic url 
              <div *ngFor="let user of users">
                  <a [routerLink]=" ['/page', user.id ] " [routerLinkActive]=" 'active' " [routerLinkActiveOptions]=" { exact: true} ">User Page</a> // url should be /user/id
                </div>

      => Query Params -  url?key=value&key=value
        We can send data from query parameter. Query params visible in the url. most used for querying, searching and filtering data etc.

        import { ActivatedRoute } from '@angular/router';
        <a [routerLink]="['/products']" [queryParams]="{ order: 'popular'}" > Products </a>
        this.router.navigate( ['/products'], { queryParams: { order: 'popular', 'price-range': 'not-cheap' } } );
        or  this.router.navigate(["URLPathName"]);
        this.route.queryParams.subscribe(params => { console.log(params);  } );

      => Fragment route (#)
        A fragment in a route is a link which jump to a section or a content in the html page, Which content the ID mentioned the fragment. A fragment comes after a # sign.

        localhost:4200/home#service => service is fragment
        <a routerLink="home" fragment="service">Home</a>
        <a routerLink="home" fragment="about">Home</a>
        this.activatedRoute.fragment.subscribe( res => { this.jumpToSection(res); console.log(res); });

        jumpToSection(selection){
          document.getElementById(selection).scrollIntoView({behavior: 'smooth'})
        }

      => Wild card route 
          wild card route nothing but user whenever enter the route which is invalid or something does not exist
          then wild card route intercept
          { path: '**', component: HomeComponent }
          
        => router Change detector 
          import { Router, Event, NavigationStart, NavigationEnd, NavigationError} from '@angular/router';
            constructor(private router: Router) {
                this.currentRoute = "";
                this.router.events.subscribe((event: Event) => {
                    if (event instanceof NavigationStart) {
                        console.log('Route change detected');
                    }
                    if (event instanceof NavigationEnd) {
                        this.currentRoute = event.url;          
                        console.log(event);
                    }

                    if (event instanceof NavigationError) {
                        // Present error to user
                        console.log(event.error);
                    }
                });

            }

        => Optional routing
          exmaple => url;key=value

        => Relative Navigation 
          Only need to change routing name on routing file no need to change all the places routingName(pathName). but when navigation we need to use raltive navigation. 
          ex. this.router.navigate('[userListId]', { realtiveTo: this.router}); //
          ex. this.router.navigate('[../]', { realtiveTo: this.router}); //

      => Activated route 
        ActivatedRoute is a service, that provides route-specific information associated with a component that is loaded in an outlet.  We use it to find Route Parameters, Query Parameters, URL Fragments, Static Data attached to the Route, Route Configuration that is matched this route, and ActivatedRoute instance of the root, parent, firstChild, and all children components, etc

      => Absolute path and relative path
        When we use a slash(/) before the router link path, in that case it use absolute path and the path is directly append to root url.
        If we dont use slash(/) before the route link path it is called relative path.
        
        <a routerLink="/about">About</a> => Absolute path
        localhost:4200/about

        <a routerLink="home">Home</a> => Relative path
        localhost:4200/about/home

      => Route guard or Auth guard
        Angular route guards can be used to control whether the user can navigate to or way from a route based on a given condition.
        We need to restrict the user from accessing certain routes.

        In angular, guard used to control access to routes based on certain conditions.
        AuthGuard is used to protect the routes from unauthorized access in angular. They help ensure that users navigate our application securely and efficiently.
        - CanActive (route activation) -> If a route can be accessed by a user or not. Useful when user dont have authority to user that route or page.
        - CanActiveChild (child route activation) -> If a user can leave a route or not. The guard is useful in case where the user might have some pending changes, which was not saved.
        - CanDeactivate (route deactivation) -> It determines whether a child route can be activated or not. When the user has filed a form like registration from and tries to navigate away without submiting. In that case, before navigating the user away, we might want to confirm if he wants to submit the data.
          - CanLoad (module loading)
        - Resolve (data prefetching)

        { path: 'contact', component: 'contactComponent' canDeactivate: [deactivateService] }  
        { path: 'courses' canActivateChild:[canACtivateChildFn], children:[
          { path: 'course/:id', component: xxxxx, CanActive: [canActivateGaud] }, 
          { path: 'popular', component: xxxxx, CanActive: [canActivateGaud] }, 
        ] }
        
        => Route Navigation Event 
          In angular, when we navigate from one route to another rote, there is a sequence of navigation events that gets
          triggered by angular router. We can subscribe to these events and execute some logic if we want.
          RouterModule.forRoot(routes, {enableTracing: true});

  => Pipe 
    pipe use for DATA manipulation means change data one formate to another formate.
    Angular has in-build pipe like titleCase, uppercase and lowercase, Percentage.
    we can also create custom pipe [ ng g pipe pipeName ].
    Pipe can be provided with argument by using colon ( : ) sign.

    html => {{ 10 | pipeName: arg1}} => passing argument after the semicolon(:)
    pipe file => const [arg1] = args; => get the argument

    {{ property | uppercase }} => Convert string to upper case.
    {{ property | slice : startIndex : endIndex }} => get part of string, between startIndex to endIndex.
    {{ property | number : .2 }} => Provide digit grouping and controls decimal places.
    {{ property | currency: 'USD' }} => Provide currency symbol 
    {{ property | json }} => convert javascript object into json formate 
    
  => custom pipe 
    Inherit PipeTransform interface and implement its transform method.

      <p>{{ score | percentage: totalScore: 2}}</p>

    import { Pipe, PipeTransform } from '@angular/core';
      @Pipe({ name: 'percentage' })
      export class PercentagePipe implements PipeTransform{
          transform(value: number, totalMark: number, decimal: number = 0) : string { // value = score, decimal = 2
              return (value / totalMark * 100).toFixed(decimal) + '%';
          }
      }

  => Slice pipe 
    Slice pipe take two parameter startIndex and endIndex and it get part of string, between startIndex to endIndex.

  => Pure pipe
    All the pipes are by default pure pipe. Pure pipe is faster then impure pipe.
    Pure pipe doesn't re-execute, in case of any changes to the object properties.
    Pure pipe doesn't re-execute, in case of any elements added or removed in the array.
    A pure pipe is only called when Angular detects a change in the value or the parameters passed to a pipe.
    Jispe pipe use kiya hai uski value change honi chahiye.

  => Impure pipe 
    The pipe is executed on every change detection. It re-execute automatically if any value or element added or remove.
    impure pipe is called for every change detection cycle no matter whether the value or parameter(s) changes.
      @Pipe {
        name: 'pipeName',
        pure: false
      }

  => Why Async pipe is impure?
    Async is an example of an impure pipe. It is always checking for new input data.
    The async pipe subscribes to an Observable or Promise and returns the latest value it has emitted. When a new value is emitted, the async pipe marks the component to be checked for changes. When the component gets destroyed, the async pipe unsubscribes automatically to avoid potential memory leaks.  

    <p>Total Students: {{arrData.totalStudent | async }}

  => Model Class
    model defined for data structure and validation. Its is part of typescript. 
    Model class reflect the data from database server.
    ex on object for validation we have to make interface.

    ng g class ModelClassName

      obj = {
        name: string = 'mike',
        num: number = 1,
        Indian: boolean = true,
        add: any = '12, mumbai '
      }

  => Service 
    Service where we write our common logic and interacting with API's. and sharing common logic to 
    different components. Service is just a class. sharing data between components.
    It does bring the injectable and has. Injectable decorator and it's provide to application level.

    services is a common reusable piece of functionality shared between different components  
    Service use for sharing data between components. add private  access modifier on constructor.

    app-module.ts => import httpClientModule
    service.ts - import httpClient
    
    => Master service code
      ... ghi.component.ts
            getUser(){
              this.isLoading = true; var data = {};
              this.def.getUser(data).subscribe({
                next:(v) =>{   },
                error:(e) => { console.log('HTTP Error', e); }
              })
            }

      .... def.service.ts
        getUserList(body: any): Observable<any> {
          const url = this.api + 'listApi';
          return this.abc.fnGetData(body, url);
        }
        addUpdateUser(body: any): Observable<any> {
          var url = this.api + '/addApi';
          var updateUrl = this.api + '/updateApi';
          return this.abc.fnAddUpdateFormData(body, "primaryID", url, updateUrl);
        }
        deleteUser(userId: number){
          var url = this.api + '/DeleteUserByUserId?userId=' + userId;
          return this.masterService.fnDeleteMethod(url);
        }
      .... abc.service.ts
        fnAddUpdateData(body:any, dataId:any,  url:string, updateUrl:string ){    
          Object.keys(body).forEach(key => {      
            body[key] = (body[key] === "0" || body[key] == "" || body[key] == "null") ? null : body[key];
          });
          body.modifiedBy = this.arrEmpData["empUserName"], body.modifiedDate = this.getCurrentDateTime(), body.modifiedIp = this.ipAddress;      
          if (body == 0 || body[dataId] == "" || body[dataId] == undefined) {
            body.createdBy = this.arrEmpData["empUserName"], body.createdDate = this.getCurrentDateTime(), body.createdIp = this.ipAddress;
            return this.http.post<any>(url, JSON.stringify(body), this.headerOption)
              .pipe(retry(1), catchError(this.handleError));
          }
          else {
            return this.http.put<any>(updateUrl, JSON.stringify(body), this.headerOption)
              .pipe(retry(1), catchError(this.handleError));
          }
        }
        fnGetData(body:any, url : string){       
          Object.keys(body).forEach(key => {      
            body[key] = (body[key] == "0" || body[key] == "" || body[key] == "null") ? null : body[key];
          });
          return this.http.post<any>(url, JSON.stringify(body), this.headerOption)
          .pipe(retry(1), catchError(this.handleError));
        } 
        fnDeleteMethod(url: string): Observable<any> {
          const headers = { 'Authorization': 'Bearer my-token', 'My-Custom-Header': 'foobar' };
          return this.http.delete<any>(url, {headers});
        }

  => Cross origin error 
    Domain and server url both are different.  

  => Observable and Observer 
    Observable(event emitter) -> Observer (Event listener Subscriber) -> Handler (Event Handler)

    "Observable and Observer" is a pattern of message passing from "publisher" to "subscriber".
    
      -> flow of functionality
        . Observable is created.
        . Observer subscribe to the observable
        . Observable can pass message (notification) to Observer.
        . Each time, when the Observable passes a notification, it received by Observer.
      -> Real time use 
        . While receiving response form AJAX.
        . While performing large tasks such as uploading the files, converting content into PDF formate etc.
      -> Observable execute only when the observer subscribe to it.

    => Observable 
      Use observable because if we dealing with asynchronous data like fetching data from server. 
      Observable are sequence of data that gets emitted asynchronously time to time.
      Observable handle variety of asynchronous operations.
      An Observable can deliver multiple values of any type - literal, message or event 

      Subscribe => subscribe is listen to our data and our logic what we want to do with the data.

      -) how to create Observable
          1. import "Observable" and "of"
          1.1 RxJs operator 'of' 
            -> convert any array into Observable
          1.2 new Observable
          1.3 user '$' symbol - so we know to that variable is Observable.   
          1.4 Observable are useless unless we subscribe to it
            -> Subscribe
            -> toPromise
            -> pipe 
          1.5 automatically the values are reflecting -> Subscribe to the Observable  
        
        example 
          // Observable
            myObservable = new  Observable((observer)=>{
              observer.next([1,2,3,4,5]);
            }) 
          getObservaleValue(){
            // Observer - next, error, complete
            this.myObservable.subscribe((resp)=>{
              console.log(resp); // [1,2,3,4,5]
            })

            this.myObservable.subscribe({
              next:(v) => {    },
              error:(e) => {   },
              complete(){   }
            })
          }

    => Of Operator
        The "Of operator" create an observable from the arguments that we pass into it. we can pass any number of argument to "OF Operator". Each argument emitted separately one after the other. It send the complete single at the end.

        ex: myObservable = Of(this.arrData, this.arrTemp, 'hello');

    => From Operator
        The "From Operator" takes a single argument which can be iterated over and convert it into an observable.
        It send the complete single at the end once the iteration completed.
        If we want to convert a promise to observable "From Operator" is the best way to do that.

    => Map and Filter Operator 
        It returns observable
        ex : myObservable = from[12,12,2,1 4, 3];
          transferObs = this.myObservable.pipe(map(val)=>{ 
            return val * 2;
          })  

    => transfer data between siblings
        import { Subject } from 'rxjs';
        obs = new Subject<any>();
        // set 
          this.ServiceName.obs.next(data);
        //get 
        this.ServiceName.obs.asObservable().subscribe(x => {
            return this.getObs = x;
          });

    => Subject Observable 
        It does not take initial value. Send update value where it will subscribe.

    => BehaviorSubject 
        It take initial value. Send update value where it will subscribe.

    => AsyncSubject
        AsyncSubject only passes the last emitted value to all its subscribers once the complete method is called on it.

        var asyncSubject = new AsyncSubject();
        asyncSubject.next(100);
        asyncSubject.next(200);
        asyncSubject.next(300);
        asyncSubject.complete();
        asyncSubject.next(400);

        asyncSubject.subscribe((data)=>{
          console.log(data); // 300
        })

  => reactive form 
    When we have complex form means more fields with the form then use reactive form. We create the form model with form group, form controls and form arrays in component class and also we defined validation rules in the component class itself.
    - Create dynamic controls easier, -structure of the form is defined in the typescript class.

    FormGroup => will control hole form and it will handle are what we are getting in side the complete form and valid or not. Store the form control in the form of key value pair in an object.
    FormControl => Specifically handle a input fields, form controls are classes that can hold both the data values and the validation information of any form element. 
    formArray => Stores the form control as an element of an array.

     import ReactiveFormsModule on app.module file.

      <form [formGroup]="myForm" (ngSubmit)="onSubmitReactFrom()" >
        <div formGroupName="fullName">
          <div>
            <input formControlName="fistName" name="fName" type="text" placeholder="first Name" 
              [class]="{'is-invalid':{ myForm.get('fullName.firstName').invalid && (myForm.get('fullName.firstName').dirty || myForm.get('fullName.firstName').touched || myForm.submitted ) },
              'is-valid':{ myForm.get('fullName.firstName').valid && (myForm.get('fullName.firstName').dirty || myForm.get('fullName.firstName').touched || myForm.submitted ) }
            /> 

              <span class="text-danger" *ngIf=" myForm.get('fullName.firstName').invalid && (myForm.get('fullName.firstName').dirty || myForm.get('fullName.firstName').touched || myForm.submitted ) && myForm.get('fullName.firstName').error?.required  ">
                First name can't be blank
              </span>

              <span class="text-danger" *ngIf=" myForm.get('fullName.firstName').invalid && (myForm.get('fullName.firstName').dirty || myForm.get('fullName.firstName').touched || myForm.submitted ) && myForm.get('fullName.firstName').error?.minlength  ">
                First name should contain at least 3 characters
              </span>

              <span class="text-danger" *ngIf="newProjectID.invalid && (newProjectID.dirty || newProjectID.touched || newForm.submitted) && newProjectID.errors?.['pattern'] ">
                Project ID should contain numbers only
              </span>

          </div>
        </div>
        
          <div formArrayName="lessons">
            <div *ngFor="let lessonForm of lessons.controls; let i = index" >
              <input formControlName="title" type="text" placeholder="title" /> 
              <input formControlName="level" type="text" placeholder="level" /> 
            </div>
          </div>

        <input type="submit" value="Submit" />
      </form>
      <button mat-mini-fab (click)="addSubItem(i)">Add Item</button>


      import { FormGroup, FormBuilder, Validators } from '@angular/forms';
      myForm !: FormGroup;
      constructor(private formBuilder: FormBuilder){}

      myForm = this.formBuilder.group({
        fullName: this.formBuilder.group({
          fistName : ['', [Validators.required, Validators.minLength(3)]],
          email: new FormControl('', [Validators.required, Validators.pattern("^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$")]),
          phone: new FormControl('', [Validators.required, Validators.pattern("^[7-9][0-9]{9}$")]),
          lessons: this.formBuilder.array([]) // Initialize an empty FormArray
        }),
      })

      get formControl(): {[key: string]: abstraction} {
        return this.myForm.controls;
      }

      getlessons(itemIndex: number) {
        //return (this.lessons.at(itemIndex) as FormGroup).get('lessons') as FormArray;
        return this.myForm.controls["lessons"] as FormArray;
      }
      addLesson(itemIndex: number) {
        const LessonForm = this.fb.group({
          title: new FormControl(''),
          level: new FormControl(''),
        });
        this.getlessons(itemIndex).push(LessonForm);
      }
      deleteLesson(itemIndex: number) {
        this.getlessons.removeAt(itemIndex);
      }

      onSubmitReactFrom(){
        this.myForm["submitted"] = true;
        if(this.myForm.valid){
        console.log(this.myForm.value)
        }
      }

      => reset formData 
        rest(){
          var formData = new FormData();
            for (var key in data) {
            if(typeof data[key] == "string")  data[key] = data[key].trim();
            formData.append(key, data[key]);
          }
        }

      => specific field reset
      this.dataForm.controls['fieldName'].reset();
      this.addLesson().at(index).patchValue({ title: 'hellow' });

    => Attached image 
        <input type="file" name="fuAppDocumentResume" (change)="getFile($event, 'resumeFile')" />
          docResumeFile: any = null;
          getFile(e: any, fileType: string) {
          var files = e.target.files[0];
          if (fileType == 'resumeFile' && files.size <= 1000000) {  this.docResumeFile = files; }
          else { this.docResumeFile = null; this.dataForm.controls['file'].reset(); }
        }
      
    => valueChanges
          valueChanges - is an event which is raised by angular form whenever the value of the FormControl, FromGroup and FormArray changes.
        initForm(){
          this.myForm.get('fistName').valueChanges.subscribe((value)=>{ console.log(value); }) // on firstName value change.
          or 
          this.myForm.valueChanges.subscribe((value)=>{ console.log(value); }) // all form data on any input value change.
        }

    => statusChanges
          The statusChanges is an event which is raised by angular forms whenever angular calculates the validation status of a FormControl, FormGroup and FormArray changes.  It returns Valid or Invalid.
            initForm(){
              this.myForm.get('email')?.statusChanges.subscribe((val)=>{
                console.log('First Name => '+ val);
              })
            }


    => Async Validator
        We use async validator when we need to send an HTTP request to the server to check if the data entered in a form element is valid or not.
         - The async validator must return either a promise or an observable.
         - Angular does not provide any build-in async validator. Angular all the validators are sync validators.

    => patchValue 
        The PatchValue is used to update only a subset of the elements of the FormGroup or FormArray. 
        It will only update the matching objects and ignores the rest.
        var firstName = 'Mike Tyson';
        this.dataForm.get("firstName")?.patchValue(firstName);

    => valueChanges Observable 
      Pass notification with value, every time, when any form element's value is changed.
      this.myForm.ValueChanges.subscribe((value)=> { console.log(value) })

    => setValue 
      Overwrite all the form element in the form group.
      We must pass values of all the form elements.
      this.myForm.setValue({ property: value })
    
    => reset 
      clear all the values form the form elements.
      this.myForm.reset()

      clear all the values form the form elements.
      And also updates the specific form elements.
      this.myForm.reset({ property: value })

  => Injector 
    Injectors are data structures that store instructions detailing where and how services form. 
    @Injectable is a decorator in Angular framework, it allows the service to be injected in Components or other service.

  => provider 
    A provider is an object declared to Angular so that it can be injected in the constructor of your components, directives and other classes instantiated by Angular.

    => What is the use of providers in Angular?
      Providers are classes that create and manage service objects the first time that Angular needs to resolve a dependency. Providers is used to register the classes to an angular module as a service

    => Interceptors : Interceptors in Angular are like security guards or middlemen for HTTP requests.
      Data base domain and where we are accessing api that domain is different then intercept comes in the picture.
      Adding authentication tokens
      Logging requests
      Handling errors in one place

      Change detection => any time any event occur its run like scroll, click, press any key.

  =>  View encapsulation = Encapsulation means hiding data and behavior form outside world.
        use for styling, Where component css styles are encapsulated into the components view and do not effect the rest of the application.
        view encapsulation angular adds some unique HTML attributes to the component CSS style and also the view. So Each component
        there will be a unique attribute which will be added to each HTML element in that component.

      ViewEncapsulation.Emulated => (default) children will not get any style form its parent
      ViewEncapsulation.None => style will affect to child component.
      ViewEncapsulation.ShadowDOM => Stay Private, don't get any style form others, It create own shadow DOM separate from the main DOM. styles and DOM are completely isolated from the rest of the application.

      @Component({
        encapsulation: ViewEncapsulation.None;
      })

  => ng-template 
    It is pre-defined special element. which may contain one more html element.
    <ng-template #myTemplate>
      <h1>hellow</h1>
      <p>asdasd</p>
    </ng-template>

    <div #ngTemplateOutlet="myTemplate"></div>

  => ngModule 

  => ng Content
    Ng content use as a projection to take Html into another component with <ng-content></ng-content> user can present there own content.
    ex: <app-home> Content </app-home>

  => template statement
    Template statement is response on event raise by target like element, component or a directive. 

  => Dependencies injection 
    Component needs something like a service, dependencies is the way to provided.
    DI is wired into the angular framework and used everywhere to provide new component with the services or other things they need.

  => Typescript 
    Typescript is super set of javascript. That means any valid javascript code also valid typescript code. Its added type to the javascript. 

  => subject and BehaviorSubject?
    A BehaviorSubject holds one value (so we actually need to initialize a default value). When it is subscribed it emits that value immediately. A Subject on the other hand, does not hold a value.
    In Subject, the subscribers will only receive the upcoming value. In BehaviorSubject, the subscribers will receive the previous value and also upcoming value.

  => safe navigation 
    The Safe Navigation Operator is also known as the "Elvis Operator". This operator is very useful to protect against null and undefined values in property paths.

=> virtual scrolling
   Virtual scrolling is an alternative to paging. 

=> Infinite SCroll
    When we scroll down it get automatically loaded the DOM. It there are lot of data taking to much time load then we use infinite scroll.

=> Optimized performance 
  - lazyLoading - Split our app into smaller modules loaded on-demand. 
  - Ahead of time compilation (AOT) - Compiler templates ahead of time for faster startup.
  - Tree shaking - Remove used code and dependencies
  - Optimized image 
  - Bundle optimized - Use webpack to create smaller bundles.
  - service workers - Implement caching for offline access.
  - change detection - use OnPush and async pipe for efficient updates.
  - component optimized - minimize by trackBy, pure pipes, and detach change detectors.
  - HTTP Request - use interceptor for bundle request 

=> Check component how much time take and size of the component. 
  - Source map explorer or webpack bundle analyzer

=> Check code quality 
  - SonarQube                                                     

=> AOT and JIT 
  AOT - Ahead of time compilation
    AOT giving runtime errors. It will create javascript bundle files before its loading to the DOM.
    Compiles code before the Angular application is loaded in the browser.
    AOT produces smaller bundle sizes, which means faster downloads for users.
    Recommended to use of production build.

  JIT - Just in time compilation
    Compiles Code during runtime when the Angular app is launched in the client’s browser.
    Produces larger bundle sizes due to in-browser compilation, potentially impacting loading speed.
    Recommended to use for local development

=> Stream Data 
  Stream data can return data into in small chunks not the big chunks.
  ex: Video steaming, when video size is around 1GB, then streaming send data chunks data to the client.

=> Promise vs Observable 
  A promise cannot handles stream of asynchronous data. It always returns a single value. On the other hand, we can use 
  observable to handle steam of asynchronous data. It can return multiple values.

  A promise will certainly return a data even if no code is using that data. Whereas an observable will return a data 
  only if someone is going to use that data.

  A promise is native to javascript program. Whereas an observable is not native to javascript and it is provided by 'RxJS' library.

  The promise will resolve or reject eventually, and there's no way to stop it from being executed. 
  Observable: An observable can be canceled. If you unsubscribe from an observable , it stops emitting values

=> CUSTOM_ELEMENTS_SCHEMA
  "add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas'" occurs when you're trying to use custom elements 
  (such as web components or elements that Angular doesn't recognize) within your Angular component templates.

=> What is RXJS
  RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using Observables to handling asynchronous 
  operations. Handling Asynchronous Data.
  For accessing data we need to subscribe the observable.
  With the help filter, map, merge, switchMap of operators we can transform data.
  
  Subject is like a hybrid between an observable and an observer. A subject can have many subscriber, but it only emit the same value all of them.

=> Authentication vs Authorization
  Authentication = "Who are you?" - It’s the process of verifying a user's identity.
  Logging in with a username and password.

  Authorization = "What can you do?" - It happens after authentication.
  It checks if the user has permission to access a resource

=> Eager loading 
  The default behavior in Angular. All components and modules are loaded at app startup, whether they’re immediately needed or not.

=> lazy loading
  Components or modules are loaded only when needed (e.g., when navigating to a route).
  Helps reduce initial load time by splitting the app into chunks.

=> Pre loading 
  A hybrid of eager + lazy. Angular loads modules in the background after the app starts.
  Improves user experience by preloading lazy-loaded routes before users actually visit them.

  Speed up future route access

  @NgModule({
    imports: [RouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules })],
  })

=> Resolver 
  a Resolver is a powerful feature used with routing to fetch data before navigating to a route.
  A Resolver is a service that runs before a route is activated, and it helps:
    Fetch necessary data (like user details, settings, etc.)
    Ensure the component only loads once the data is ready
    Prevent showing "loading spinners" inside the component

    | Feature           | Description                              
    | ----------------- | ---------------------------------------- 
    |  Purpose        | Load data before route activates     
    |  Where it goes  | In route config under `resolve`          
    |  Returns        | Observable, Promise, or plain value      
    |  Useful for     | API calls, auth checks, loading settings 

  export const routes: Routes = [
  { path: 'user', component: UserComponent, resolve: { userData: UserResolverService }  }
  ];


    import { Resolve } from '@angular/router';
  export class UserResolverService implements Resolve<any> {
    constructor(private userService: UserService) {}

    resolve(): Observable<any> {
      return this.userService.getUser(); // Example HTTP call
    }
  }

=> App Initializer 
   the APP_INITIALIZER is a powerful built-in dependency injection (DI) token that lets you run custom code before the application fully initializes.
   It’s a special Angular token used to delay app startup until some async operations (like fetching config, checking auth, loading language files, etc.) complete.

  Useful for setting up app-wide settings before components load.

  Angular will wait for all functions provided under APP_INITIALIZER to finish executing before bootstrapping the app.

  If any initializer returns a Promise, Angular will wait for it to resolve.


  | Rule                       | Description                                             |
  | -------------------------- | ------------------------------------------------------- |
  | Must return a function     | The factory must return a function (can return Promise) |
  | Can be async               | Supports Promises for async setup                       |
  | `multi: true`              | Required so Angular allows multiple initializers        |
  | Runs **before** app starts | Blocks app startup until it completes                   |

=> Dark mode to light mode how to change.
    /* Light Mode */
    :root {
      --background-color: #ffffff;
      --text-color: #000000;
    }

    /* Dark Mode */
    [data-theme='dark'] {
      --background-color: #121212;
      --text-color: #ffffff;
    }

    /* Use variables for styles */
    body {
      background-color: var(--background-color);
      color: var(--text-color);
    }

=> ForkJoin 
  You want to execute multiple HTTP requests in parallel and wait for all of them to finish.

  You want the last emitted value of each Observable when all Observables complete

  ForkJoin is an RxJS operator used to combine multiple Observables and wait for all of them to complete before emitting a single result.

  It waits for all provided Observables to complete and then emits the last emitted value from each Observable. If one Observable doesn't emit a value or completes with an error, the entire ForkJoin fails.

  fetchData() {
    const request1 = this.http.get('https://api.example.com/data1');
    const request2 = this.http.get('https://api.example.com/data2');
    const request3 = this.http.get('https://api.example.com/data3');

    forkJoin([request1, request2, request3]).subscribe(
      ([response1, response2, response3]) => {
        console.log('Response 1:', response1);
        console.log('Response 2:', response2);
        console.log('Response 3:', response3);
      },
      error => {
        console.error('Error:', error);
      }
    );
  }

=> switchMap 
  switchMap is a transforming operator in RxJS that maps an observable to another observable, and when a new value arrives from the source observable, it cancels the previous inner observable and switches to the new one.

  It’s commonly used in scenarios where you need to cancel ongoing operations (like HTTP requests) when a new operation is triggered, for example, in a search input that cancels previous requests as the user types.

    Cancels Previous Requests:
    Only the Latest Observable Matters:


  onSearch(event: any) {
    this.searchTerm = event.target.value;

    // Observable for handling the search logic
    new Observable(observer => observer.next(this.searchTerm)).pipe(
      debounceTime(300), // Wait for 300ms after the last input
      switchMap(term => 
        this.http.get<any[]>(`https://api.example.com/search?q=${term}`).pipe(
          catchError(error => {
            console.error('Error:', error);
            return []; // Return empty array on error
          })
        )
      )
    ).subscribe(results => {
      this.searchResults = results;
    });
  }


  switchMap to switch between different actions based on user interaction, such as logging out of a session.
  switchMap is used to switch between different actions based on whether the user is logged in or not.

=> trackBy
  trackBy is an important performance optimization when using *ngFor to display lists. It allows Angular to track changes to list items efficiently and helps Angular know which items have changed, added, or removed from the list.

  Without trackBy, Angular re-renders the entire list when the data changes, even if only a few items have changed. This can be inefficient, especially with large lists.

=>  from and of RXJS
  | Feature     | `from()`                             | `of()`                       |
  | ----------- | ------------------------------------ | ---------------------------- |
  | Input types | Array, Promise, Iterable, Observable | Any value or multiple values |
  | Emission    | Emits each item or resolved value    | Emits input(s) as-is         |
  | Use case    | Converting async or iterable types   | Creating a simple observable |

    import { from } from 'rxjs';

    from([1, 2, 3]).subscribe(console.log);
    // Output:
    // 1
    // 2
    // 3

    from(Promise.resolve('hello')).subscribe(console.log);
    // Output:
    // hello

    import { of } from 'rxjs';

    of([1, 2, 3]).subscribe(console.log);
    // Output:
    // [1, 2, 3]

    of(1, 2, 3).subscribe(console.log);
    // Output:
    // 1
    // 2
    // 3

=> Signal : Auto-tracked
  A Signal is a special variable in Angular that automatically updates anything that depends on it when its value changes.
  A signal holds a single value and allows other parts of the app to react automatically when that value changes.
  Think of them as "reactive variables" that automatically notify Angular when their value changes—so only the affected parts of your app re-render.

  Signals are reactive primitives that:
    - Hold a value.
    - Allow automatic tracking of where that value is used.
    - Trigger updates only where needed when the value changes.

  Benefits
    | Benefit                     | Description                                                           |
    | --------------------------- | --------------------------------------------------------------------- |
    | **Fine-grained reactivity** | Only the parts of the UI that depend on a signal get updated.         |
    | **Better performance**      | Avoids unnecessary change detection cycles.                           |
    | **Predictable updates**     | Changes propagate synchronously and predictably.                      |
    | **Simpler mental model**    | No need to subscribe/unsubscribe like RxJS.                           |
    | **Integrated into Angular** | Officially supported and works seamlessly with the Angular ecosystem. |

    Only affected components or values update.
    Avoids running change detection for unrelated parts of the app.
    Easier to read and write than RxJS observables and subscriptions.
    No need to manage unsubscribing.
    No accidental side-effects or over-rendering.
    Signals are the basis for Angular’s move to fine-grained reactivity, non-zone change detection, and better SSR (Server-Side Rendering).

  example
    const count = signal(0); // A counter starts at 0
    count.set(5); // We change the count to 5
    console.log(count()); // It prints 5
    const double = computed(() => count() * 2); // double is always twice the count
    console.log(double()); // It prints 10
    // Need add on constructor
    effect(() => {
      console.log('Count is now', count()); // This runs every time count changes
    });

    color = signal(['red', 'green', 'yellow']);
    this.color.update((ele)=> [...ele, 'orange']);


  update() — For changing a signal’s value
    Think of it like telling a signal: “Hey, I want to change your value based on what it currently is.”
    const count = signal(0);
    count.update(c => c + 1); // adds 1 to the current value

  computed() — For creating a reactive value
    Use computed() when you want to create a new value that depends on other signals, and let Angular keep it up to date.
    Think of it like asking Angular: “Please give me a value that always follows some logic based on another signal.”
    const count = signal(5);
    const double = computed(() => count() * 2);
    console.log(double()); // prints 10

  effect() => Effects run at least once. It keep track or single. We do not set signal value in effects because it go to infinite.








=> What is NPM 

=> Compress 
=> Angular Analyzer
=> PWA APP
=> Multi step form.
=> How to check code quality.
=> How much components get time to load - angular Analyzer package.
=> Component size


