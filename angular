









https://v2.angular.io/docs/ts/latest/guide/template-syntax.html#!#template-input-variables

=> npm install -g @angular/cli@latest 
=> ng new myProjectName -- create new project
=> ng serve -- start (npm start)
=> CTR + C -- stop
=> ng generate component xyz -- generate component
=> ng g pipe pipeName
=> ng generate module ModuleName --route ModuleName --module app.module
=> npm ng build => build
=> routing and navigation -- on change of URL load the component - <router-outlet></router-outlet>
=> service -- to access the common method
=> http -- ajax
=> Change port => ng serve --open --port=3200 -> between 1024 to 65535

---------------------------
1. can we get observable value on click event.


---code---
1. npm i jQuery or npm install jQuery :- 
    npm i bootstrap@3
    add jQuery and bootstrap link in angular.json file. In side architecture section.
    then re-start project.
2. npm i -- package.json dependencies get downloaded in node_modules folder
3. component 
     ts => decorator- @component
        selector: 'my-page', '.my-page', '[my-page]'
                  <my-page>, <div class="my-page">, <div my-page>

  ng generate component firstComponent || ng g c firstComponent   (ng g c NewCompo --spec=false)
   import { Component } from '@angular/core';

  @Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css']
  })
  export class AppComponent {
    title = 'firstProject';
  }

4. SPEC.TS => test file 

5. routing 
  
  route module / lazy loading
    ng generate module ModuleName --route ModuleName --module app.module

    app-routing.ts
  { path: 'moduleOne', loadChildren: () => import('./module-one/module-one.module').then(m => m.ModuleOneModule) }

  module-one-routing.module.ts
  { path: '', component: ModuleOneComponent }


 -----------------------------------
  child routing
  app-routing.ts
  { path: 'blog', component: BlogComponent,
  children :[
    { path: 'blogOne', component: BlogOneComponent },
    { path: 'blogTwo', component: BlogTwoComponent }
  ]},

  <a routerLink="blog"> Blog </a> 
  <a routerLink="blog/blogOne"> Blog One </a> 
  <router-outlet></router-outlet>
  
 -----------------------------------
 
  { path: '**', component: HomeComponent },
  { path: '',   redirectTo: '', pathMatch: 'full', component: HomeComponent }
  { path: '',   redirectTo: 'HomeComponent', pathMatch: 'full' }


6. data binding 
  {{data}}  --> using interpolation to value binding
  [property]="data" --> attribute Binding to DOM  
  (click)="save()" --> Event Binding 
  [(ngModel)]="data" --> two way data biding [FormsModule] 
  
  <button [disabled]="!isVisible" [style.color]="textColor" [class.active]="isActive" (click)="save()">
    Save
  </button>


  ==> one Way Binding with event or with template.
    => with event binding
    <input type="text" [ngClass]="className" (keyup)="onKeyUp($event)" />
      value1: any;
      onKeyUp(x:any){
          this.value1 = x.target.value;
        }

    => with template binding
    <input type="text" #valueOne /> // #valueOne is variable
    <button [ngClass]="classBtn" (click)="callClick(valueOne.value)">Add</button>

7. for loop
  *ngFor="let value of arrayName;let i=index"  

8. pipe [|] ---> [ CommonModule ]   --> titlecase, uppercase, lowercase  
  {{ arrayObject | json }} {{ varName | uppercase}}

  pipe is in-build function, use for data manipulation.
  custom pipe -> ng g pipe pipeName

  transform(value: unknown, index: any): unknown {
    if(index % 2 !== 0){
      return value + " => ";
    } else {
      return value;
    }
  }

  <td> {{ user.name | my: user.age }} </td>

9. service := access from any where.  
    to share a data between component to component.

10. Ternary Operator
  'padding-top': true ? '0' : '30px' // if and else condition 

11.  If and else condition

      <div *ngIf="isLoggedIn; else loggedOut"> Welcome back, friend. </div>
      <ng-template #loggedOut> Please friend, login.  </ng-template>

        or 

      <ng-template [ngIf]="isLoggedIn" [ngIfElse]="loggedOut">
        <div> Welcome back, friend.</div>
      </ng-template>

      <ng-template #loggedOut>
        <div> Please friend, login. </div>
      </ng-template>
    
       or 

      <ng-container
        *ngIf="isLoggedIn; then loggedIn; else loggedOut">
      </ng-container>
      
      <ng-template #loggedIn>
        <div> Welcome back, friend.</div>
      </ng-template>
      <ng-template #loggedOut>
        <div> Please friend, login. </div>
      </ng-template>

12. @Input decorator
    pass property from  parent to child
        parent.html
        <app-child [property]="expression"></app-child>
        parent.ts
        expression = 'Enter your message';

        child.ts
        import Input decorator.
        @Input() property:any;

        child.html
        {{ property }}

13.  @Output decorator, EventEmitter
    pass function form parent to child
    pass data from child to parent

    parent.html
    (onParentClickEvent)="func($event)"
    parent.ts 
    func(eventValue){ condition; }

    child.ts
    @Output() onParentClickEvent : EventEmitter = new EventEmitter();

    clickEvent(value){
      this.onParentClickEvent.emit(value);
    }

14. observable
   Sending data between children to children but both the children should load on same component(parent).
   observable subscribe inside the ngOnInit() lifecycle then it will work.

  service.ts
  import { Subject } from 'rxjs';
  obs = new Subject<any>();

  receiver component
  ngOnInit(): void{
    this.serviceName.obs.asObservable().subscribe(x=>{
      console.log(x)
    })  
  }

  sender component
  this.serviceName.obs.next('Rohit');

     or

  service.ts
  import { BehaviorSubject, Subject } from 'rxjs';
    
    private transferBetweenSibling = new Subject<string>();
  
    getSibling(){
      return this.transferBetweenSibling.asObservable();
    }
    onChangeSibling(val:any){
      this.transferBetweenSibling.next(val);
    }

  childOne.html
    <input type="text" name="name" id="name" [(ngModel)]="name" (keyup)="onKeyupSending()" />
  childOne.ts
    onKeyupSending(){
      this.myService.onChangeSibling(this.name); // sending data
    }
  
  childTwo.ts
    getName: string = '';
    ngOnInit(): void {
      this.myService.getSibling().subscribe(x=>{  // receive the data 
        this.getName = x;
        console.log(x);
      })
    }
    
  childTwo.html
    {{ getName }}


15. get request - import http 

    myService => import { HttpClient } from '@angular/common/http';
          constructor(private http: HttpClient) { }
    
    app-module =>  import { HttpClientModule  } from '@angular/common/http';

    onGet(){ 
      return this.httpClient.get<any>(urlName);  
    }

    onPost(data: any){
       return this.httpClient.post<any>("http://localhost:3000/",data);
    }

    onPut(data: any, id: number){
      return this.httpClient.put<any>("http://localhost:3000/" + id , data);
    }

    onDelete(id: number){
      return this.httpClient.delete<any>("http://locahost:3000/" + id);

    }

    // create custom server
    npm install -g json-server
    create - db.json // data must be an object formate
    add package.json => "mock:server": "json-server --watch db.json"
    run server => npm run mock:server

16. local storage  and session storage

    localStorage.setItem('name', 'mike')
    localStorage.getItem('name');

    sessionStorage.setItem('name', 'mike')
    sessionStorage.getItem('name');

17. template driven form
    <form #formData="ngForm" (ngSubmit)="onSubmit(formData.value)"> or <form #formData="ngForm" (ngSubmit)="onSubmit(formData)">
      <input type="text" name='text' ngModel />
    </form>

    onSubmit(values){ console.log(values); }
     or  
    onSubmit(values){ console.log(values.value); }




















-----------------------------------------------

Ng serve --open ( project open in browser)

On CMD
code .  => Open this folder on vs code

Adding Bootstrap styles links on the angular.json file On Architect / build section


* How to create angular application
    It required 3 things node, npm, angular cli.
    ng new applicationName

* what is component
     html, css, ts, spce.ts

     ts => decorator- @component
        selector: 'my-page', '.my-page', '[my-page]'
                    <my-page>, <div class="my-page">, <div my-page>

* Which File Executes First in Angular?
  First it goes to the angular.json file, It loads up main.ts (first file that executes) and read its content.
  index.html, main.ts, app-module(Know all about component in this file)

e2e => end to end test, automate test 
node modules => all third party libraries, not deployed our server
environment => store configuration setting
main.ts => starting point our application
polyfills.ts => feel the gap between browser and the javascript version to run the code in angular
test.ts => setting our environment
.editorconfig => all developer team have same setting
.gitignore => managing our code 
karma.config => test runner of javascript code 
protractor.conf.js => running tool for e2e.
tsconfig.json => typescript complier 
tslint.json => static annalistic typescript code
vendor.bundle.js => third party libraries
package.json => records important metadata about a project and contain the information about npm packages installed for the 
    project that npm uses to install dependencies, run scripts, and identify the entry point to our package.

stylesheets compile => all stylesheets compile into javascript.

=> Angular 
  Angular is javascript framework. Angular is a component based single page application that is written in typescript. It is maintained by google.

=> Directive
  Directive use for DOM manipulation.Directives are classes that add additional behavior to elements. 
  With directive we can manage forms, lists, styles and what user see.

  Components =>	Used with a template. This type of directive is the most common directive type.

  Attribute directives =>	Change the appearance or behavior of an element, component, or another directive. with NgClass, NgStyle and NgModel

  Structural directives =>	Change the structure on the DOM by adding or removing DOM elements. with the help of NgFor, NgIf and NgSwitch

  => Custom Directives
  ng g directive CustomDirective
  2 files created and update in app.module file
  CustomDirective.ts file => import { ElementRef } from '@angular/core';
    class CustomDirectiveWork {
      constructor(private el: ElementRef) {
        el.nativeElement.style.color = "red"    (with nativeElement we can access JavaScript DOM elements)
      }
    }

    <div CustomDirectiveWork> check directive work </div>


  => input properties in Directives
      <div CustomDirectiveWork [error]='Hello'> check directive work </div>

      class CustomDirectiveWork {
        @Input("error")error: string;
        constructor(private el: ElementRef) {  }
        ngOnInit(){
            this.el.nativeElement.innerHTML = "<div><span>${this.error}</span></div>"  
        }
      }



=> One Way binding => use for Data exchange
  One way binding data flow one directional. Means ts file to html.
  When we change on html file it will not change on ts.
  We can get the data with template binding or event binding

=> Two way binding => use for Data exchange
  Two way binding data flow two directional. Means when we change on ts file, it will change on html file and change on html file, it change on ts file.
  We can get the data with [(ngModel)].

=> Attribute binding
  <div [attr.title]=" 'heading' "></div>
  <img [attr.alt]=" 'srcTitle' "></img>

=> ngClass 
<div [class]=" 'first second' ">
<div [class]=" ['first', 'second'] ">
<div [class]=" {first: true, second: true, third: true} ">
<div [class]="{'first second': true}">
<div [class]=" (condition)? trueValue : falseValue ">

=> style
<div [style.color]=" 'red' "></<div>
<div [style.color]=" clrName "></<div> // .ts file clrName = 'red';
<div [style]="{ 'background-color':'green', 'padding': '10px' }"></<div>
<div [style]="{'background-color':person.country === 'UK' ? 'green' : 'red' }"></<div>


=> If and else 

  <div *ngIf=" condition "></div>
  or
  <ng-template [ngIf="condition"]></ng-template>
  or
  show = true;
  <div *ngIf="show else falseTemplate"> This condition is true! </div>
  <ng-template #falseTemplate>  <h1> Else block</h1> </ng-template>
  or
  <div *ngIf="isLoggedIn; else loggedOut"> Welcome back, friend. </div>
  <ng-template #loggedOut> Please friend, login.  </ng-template>
  or
    show = 'yes';
  <div *ngIf=" show== 'yes'; then trueTemplate; else falseTemplate"> </div>
  <ng-template #trueTemplate>  <h1> if block</h1> </ng-template>
  <ng-template #falseTemplate>  <h1> Else block</h1> </ng-template>
    or 
  <ng-template [ngIf]="isLoggedIn" [ngIfElse]="loggedOut"> <div> Welcome back, friend.</div> </ng-template>
  <ng-template #loggedOut> <div> Please friend, login. </div> </ng-template>


=> Switch case
  On one action have more condition.
  .ts -> color = 'red'
  <div [ngSwitch]="color">
    <div *ngSwitchCase="red">...</div>
    <div *ngSwitchCase="green">...</div>
    <div *ngSwitchDefault>...</div>
  </div>

=> Input decorator 
    pass property from  parent to child
        parent.html
        <app-child [property]="expression"></app-child>
        parent.ts
        expression = 'Enter your message';

        child.ts
        import Input decorator.
        @Input() property:any;

        child.html
        {{ property }}

        OR 

    <app-child [property]="expression"></app-child> 
    expression = 'some text';

    @Input("property") weCanWriteAnyName: any;
    {{ weCanWriteAnyName }} 

=> Output decorator, EventEmitter
    Some time we pass data or action child component to parent component. we can create event by using "EventEmitter" and we can raise that event by  using predefined the method "emit()".

    parent.html
    (onParentClickEvent)="func($event)"
    parent.ts 
    func(eventValue){ condition; }

    child.ts
    import output decorator
    @Output() onParentClickEvent : EventEmitter = new EventEmitter();

    clickEvent(value){
      this.onParentClickEvent.emit(value);
    }

  or 
  <app-child (someOutputName)="methodName()" ></app-child> 
  methodName(){ }

  @Output("someOutputName") eventName: EventEmitter = new EventEmitter(); 


=> @viewChild
  Parent component access all the methods and properties form child components. Single instance
  parent.ts 
    import viewChild
    @viewChild("referenceVariableName") variableName: ChildComponentName;
    func(){
      this.variableName ----> access all the method and properties
    }
  parent.html 
    <app-child #referenceVariableName ></app-child>  

=> @viewChildren 
  Parent component access all the methods and properties form child components. 
  multiple instance. Import "QueryList" and convert "QueryList to Array".

  parent.ts 
    import viewChild and QueryList 
    @viewChild("referenceVariableName") variableName: QueryList<ChildComponentName>;
    func(){
      var getAll = this.variableName.toArray();
    }
  parent.html 
    <app-child #referenceVariableName ></app-child> 


=> Component 
  component is basic ui block of code that represent the specific view.

  => Component lifecycle hooks
   Lifecycle hooks are referred to as methods on an object or component.
    In angular, every component has lifecycle. Angular create and render there components and also 
    destroy them before removing from the DOM. This is achieve with the help of lifecycle hook.
    - there are total 8 types of hooks but most used hooks are 4, 
      1. ngOnChanges() - data set or re-set data bound input properties.
      2. ngOnInit() - It is called when the component is initialized means on load time.
              used to perform actually business logic. We can write onload function on ngOnInit().
      3. ngAfterOnInit()
      4. ngOnDestroy()
    
    - Whichever lifecycle hooks we want to use    
      1. import it in the class
      2. extend the implements interface 
      3. Implement the method  

=> constructor
  The constructor() should only be used to initialize class members but shouldn't do actual “work”. 
  So we should use constructor() to set up Dependency Injection.
  dependency injection is a method in which dependencies are requested by class from the external resources.
  In the Angular constructor, a constructor argument with dependency type injects the dependencies.

=> Module 
  Module is collection of components, directives, pipes and services.
  Module use to organize the component and directives, pipes.
  Module mainly use to create meaning-full groups of component that are related to specific user, part of the project or achieve 
  some goal.
  eg: login component, register component, my profile component
  Module load only selected/ necessary components.

  export that file on module -> import on app.module.ts file -> then use those components

  ng g module moduleName
  or
  ng generate module ModuleName --route ModuleName --module app.module

=> route module / lazy loading
   when we defined routing on a specific module then we call routing module.
   with route module load only necessary route or components.


    => Multiple Router Outlets
      We can have multiple router Outlets 
      by default there is always/"at least" 1 router outlet in app.component.html file 
      When we don't provide any name for router-outlet it becomes primary 
      There should be only 1 primary 
      We can define multiple router outlets by giving name to them 
      That's why we call them "named" router outlets 
      we can give any name we want - give meaningful names 
      In routing module - if you don't define outlet - it means its primary 
      It will NOT show if you directly access it in the URL 
      Syntax should be like this  - http://localhost:4200/<primary-route>( <routerOutletName> : <secondaryPath> )


    => HashLocationStrategy 
    Hands-on examples for PathLocationStrategy 
      - Default behavior of Angular apps 

    Hands-on examples for HashLocationStrategy
      - We need to import HashLocationStrategy from @angular/core 
      - Add it to Providers array 
      - Angular will start loading our URLs using # 
        index.html/#/loans/add 


    => Parametrized Routes - Dynamic Routes 
      - We can send dynamic data or parameters to our routes. Those are visible in the url.
      - URLs will look something like this - http://localhost.com/user/10
      - While writing dynamic URLs/Params - make sure you write :(colon) for dynamic data means it can be string, integer. 
          { path: 'product/:id', component: ProductComponent }
      - Import the ActivatedRoute class 
      - We can read the value in the component class 
          - Create an object in constructor 
              constructor(private activatedRoute: ActivatedRoute){
                this.activatedRoute.parmas.subscribe( res => {
                  console.log(res) // its print id means dynamic url 
                })
              }

    => Router link 
        when ever we want to create a link we use routerLink.
        router link can be static or dynamic in nature.
        We DO NOT have to put "/" in variables in routerLink

        ex: <a routerLink="user">User Page</a>
        ex: <a [routerLink]=" 'user' ">User Page</a>
        ex: <a [routerLink]=" ['user'] ">User Page</a>
        ex:  adding dynamic url 
            <div *ngFor="let user of users">
                <a [routerLink]=" ['/page', user.id ] ">User Page</a> // url should be /user/id
              </div>


    => Query Params -  url?key=value&key=value
      We can send data from form.
      Query params visible in the url.
      most used for querying, searching and filtering data etc.

    => Wild card route 
        wild card route nothing but user whenever enter the route which is invalid or something does not exist
        then wild card route intercept
        { path: '**', component: HomeComponent }
        

=> Pipe 
  pipe use for DATA manupulation means change data one formate to another formate.
  Angular has in-build pipe like titlecase, uppercase and lowercase, Percentage.
  we can also create custom pipe [ ng g pipe pipeName ].
  Pipe can be provided with argument by using colon ( : ) sign.

  html => {{ 10 | pipeName: arg1}} => passing argument after the semicolon(:)
  pipe file => const [arg1] = args; => get the argument

  {{ property | uppercase }} => Convert string to upper case.
  {{ property | slice : startIndex : endIndex }} => get part of string, between startIndex to endIndex.
  {{ property | number : .2 }} => Provide digit grouping and controls decimal places.
  {{ property | currency: 'USD' }} => Provide currency symbol 
  {{ property | json }} => convert javascript object into json formate 

=> Model Class
  model defined for data structure and validation. Its is part of typescript. 
  Model class reflect the data from database server.
  ex on object for validation we have to make interface.

  ng g class ModelClassName

    obj = {
      name: string = 'mike',
      num: number = 1,
      Indian: boolean = true,
      add: any = '12, mumbai '
    }

=> constructor
  The constructor is a special method in the class, which automatically execute when an object is created for the class.
  constructor we inject our service.

  constructor(private myService: Service){ } - 
  here "myService" is reference variable. and in order to make this reference variable as a property of the current working class,
  we require to add the keyword "private".

=> Service 
  Service where we write our common logic and interacting with API's. and sharing common logic to 
  different components. Service is just a class. sharing data between components.
  It does bring the injectable and has. Injectable decorator and it's provide to application level.

  services is a common reusable piece of functionality shared between different components  
  Service use for sharing data between components. add private  access modifier on constructor.

  app-module.ts => import httpClientModule
  service.ts - import httpClient
  deleteSingleUser(id:number){
    const url = `${this.customUrl}/${id}`;
    return this.http.delete(url);
  }
  .ts 
    onDelete(id:any ){
    this.myService.deleteSingleUser(id).subscribe( () => {
        this.users = this.users.filter(function(user:any){
          return user.id !== id;
        });
      })
  };

  or
  if we want to use service on specific module or private use then import that service as a provider on that module.

  OR 
    onGet(): Observable<any[]> { 
      return this.httpClient.get<any>(urlName);  
    }
        this.myService.getData().subscribe(
          (response: any[]) => { this.VariableName = response;  }
        );
    --------------------------
    onPost(data: any): Observable<any> {
       return this.httpClient.post<any>("http://localhost:3000/",data);
    }


=> AJAX 
  AJAX ( asynchronous JavaScript and XMl ) is not a language, but it is a concept, Which is used to "send background request to server" 
  and also "get background response from server", without refreshing (reloading) the web page in the browser.
  status code 200 - success and status code 404/500 - error
  
  Get - Used to retrieve / search data from server.
  Post - Used to insert data to server.
  Put - Used to update data on server.
  Delete - Used to delete data from server.

=> json server 
  npm install -g json-server // install json server
  create db.json file  // json data must be object
  json-server --watch db.json --port 5000 // start server and  add on package.json file 
  add url on service.ts file
  import httpClientModule on app.module file

=> Cross origin error 
  Domain and server url both are different.  

=> Observable and Observer 
  "Observable and Observer" is a pattern of message passing from "publisher" to "subscriber".
    -> flow of functionality
      . Observable is created.
      . Observer subscribe to the observable
      . Observable can pass message (notification) to Observer.
      . Each time, when the Observable passes a notification, it received by Observer.
    -> Real time use 
      . While receiving response form AJAX.
      . While performing large tasks such as uploading the files, converting content into PDF formate etc.
    -> Observable execute only when the observer subscribe to it.

=> Observable 
  Use observable because if we dealing with asynchronous data like fetching data from server. 
  Observable are sequence of data that gets emitted asynchronously time to time.
  Observable handle variety of asynchronous operations.
  An Observable can deliver multiple values of any type - literal, message or event 

  Subscribe => subscribe is listen to our data and our logic what we want to do with the data.

  -) how to create Observable
      1. import "Observable" and "of"
      1.1 RxJs operator 'of' 
         -> convert any array into Observable
      1.2 new Observable
      1.3 user '$' symbol - so we know to that variable is Observable.   
      1.4 Observable are useless unless we subscribe to it
        -> Subscribe
        -> toPromise
        -> pipe 
      1.5 automatically the values are reflecting -> Subscribe to the Observable  
    

  => transfer data between siblings
    import { Subject } from 'rxjs';
    obs = new Subject<any>();
    // set 
      this.ServiceName.obs.next(data);
    //get 
    this.ServiceName.obs.asObservable().subscribe(x => {
        return this.getObs = x;
      });


  => BehaviorSubject 
     BehaviorSubject stores the "current value", which is lastly broadcasted to the observers.
     And whenever a new observer has subscribed to the observable the BehaviorSubject automatically 
     sends the current value to the new observer.
      
      import BehaviorSubject, subject 
     var myBehSubject = new BehaviorSubject<any>(defaultValue);
      myBehSubject.next(data);

      myBehSubject.subscribe((data) => {
        // do something with data
      })


=> one Way Binding with event or with template.
    => with event binding
    <input type="text" [ngClass]="className" (keyup)="onKeyUp($event)" />
      value1: any;
      onKeyUp(x:any){
          this.value1 = x.target.value;
        }

=> with template binding
    <input type="text" #valueOne /> // #valueOne is variable
    <button [ngClass]="classBtn" (click)="callClick(valueOne.value)">Add</button>
   
=> template driven form 
  the form which are handled in template file, html file we call them template file. because here we write
  our template code. Getting and setting the values and apply the validations, show the errors message every thing we handle in our html file. For binding we must have "name" attribute.
  It is a simple form. Validation on html file.

 <form #form="ngForm" (ngSubmit)="onSubmit(form.value)" > or <form #form="ngForm" (ngSubmit)="onSubmit(form)" > 
    <input ngModel name="name" type="text" placeholder="name" /> <br />
    <input ngModel name="email" type="email" placeholder="email"  /> <br />
    <input type="submit" value="Submit" />
  </form>

  ts - onSubmit(data){ console.log(data )} or onSubmit(data){ console.log(data.value )}

  => validation in template driven form 
    - error 
      . required -> specific that the field is mandatory (cant be blank)
      . pattern -> specific regular expression 
      . minlength -> minimum no. of characters to accept 
      . maxlength  -> maximum no. of characters to accept 
   - untouched                                          - touched 
    . true - the field is not focused at least once.      . true - the field is focused at least once.   
    . false - the field is focused at least once.         . false - the field is not focused at least once.
   
   - prestine                                           - dirty 
    . true - the field is not modified at least once.       . true - the field is modified at least once. 
    . false - the field is modified at least once.          . false - the field is not modified at least once.   
   
   - valid                                           - invalid 
    . true - the field is valid (has no errors).        . true - the field is invalid (has errors).
    . false - the field is invalid (has errors).        . false - the field is valid (has no errors).
   

      <form #newForm="ngForm" novalidate="novalidate">
            <label for="projectID">Project ID</label>
            <input type="text" id="projectID" name="projectID" class="form-control" [(ngModel)]="newProject.projectID" required="required" pattern="^[0-9]*$" #newProjectID="ngModel" [class]=" { 'is-invalid': newProjectID.invalid && (newProjectID.dirty || newProjectID.touched || newForm.submitted), 'is-valid': newProjectID.valid && (newProjectID.dirty || newProjectID.touched || newForm.submitted)} " />

            <span class="text-danger" *ngIf="newProjectID.invalid && (newProjectID.dirty || newProjectID.touched || newForm.submitted) && newProjectID.errors?.['required'] ">
              Project ID can't be blank
            </span>
            <span class="text-danger" *ngIf="newProjectID.invalid && (newProjectID.dirty || newProjectID.touched || newForm.submitted) && newProjectID.errors?.['pattern'] ">
              Project ID should contain numbers only
            </span>

      </form>



=> reactive form 
  When we have complex form means more fields with the form then use reactive form.
  when we need complex form and validation code should be written in ts file.

  FormGroup => will control hole form and it will handle are what we are getting in side the complete form and valid or not. 

  FormControl => Specifically handle a input fields

  import ReactiveFormsModule on app.module file.

  <form [formGroup]="reactFormData" (ngSubmit)="onSubmitReactFrom()" >
    <input formControlName="name" name="name" type="text" placeholder="name" /> <br />
    <input formControlName="email" name="email" type="email" placeholder="email"  /> <br />
    <input type="submit" value="Submit" />
  </form>

  import { FormControl, FormGroup } from '@angular/forms';

  reactFormData !: FormGroup;

   reactFormData = new FormGroup({
    name: new FormControl('Mike'),
    email: new FormControl('tyson@gmail.com')
  })

  onSubmitReactFrom(){
    console.log(this.reactFormData.value)
  }

  => valueChanges Observable 
    Pass notification with value, every time, when any form element's value is changed.
    this.myForm.ValueChanges.subscribe((value)=> { console.log(value) })

  => setValue 
    Overwrite all the form element in the form group.
    We must pass values of all the form elements.
    this.myForm.setValue({ property: value })

  => pathValue 
    Updates specific form element in the form group.
    We can pass only specific form element.
    this.myForm.pathValue({ property: value })
  
  => reset 
    clear all the values form the form elements.
    this.myForm.reset()

    clear all the values form the form elements.
    And also updates the specific form elements.
    this.myForm.reset({ property: value })



  => Reactive Form Validation 

    <form [formGroup]="myForm" (ngSubmit)="onSubmitReactFrom()" >
      <div formGroupName="fullName">
        <div>
          <input formControlName="fistName" name="fName" type="text" placeholder="first Name" 
            [class]="{'is-invalid':{ myForm.get('fullName.firstName').invalid && (myForm.get('fullName.firstName').dirty || myForm.get('fullName.firstName').touched || myForm.submitted ) },
            'is-valid':{ myForm.get('fullName.firstName').valid && (myForm.get('fullName.firstName').dirty || myForm.get('fullName.firstName').touched || myForm.submitted ) }
          /> 

            <span class="text-danger" *ngIf=" myForm.get('fullName.firstName').invalid && (myForm.get('fullName.firstName').dirty || myForm.get('fullName.firstName').touched || myForm.submitted ) && myForm.get('fullName.firstName').error?.required  ">
              First name can't be blank
            </span>

            <span class="text-danger" *ngIf=" myForm.get('fullName.firstName').invalid && (myForm.get('fullName.firstName').dirty || myForm.get('fullName.firstName').touched || myForm.submitted ) && myForm.get('fullName.firstName').error?.minlength  ">
              First name should contain at least 3 characters
            </span>

        </div>
        <div>
          <input formControlName="lastName" name="lName" type="text" placeholder="Last name" /> 
        </div>
      </div>
      <input formControlName="email" name="email" type="email" placeholder="email"  /> 
      <input type="submit" value="Submit" />
    </form>

    import { FormGroup, FormBuilder, Validators } from '@angular/forms';

    myForm !: FormGroup;

    constructor(private formBuilder: FormBuilder){}

    myForm = this.formBuilder.group({
      fullName: this.formBuilder.group({
        fistName : ['', [Validators.required, Validators.minLength(3)]],
        lastName : ['', [Validators.required, Validators.minLength(3)]],
      }),
      email : ['', [Validators.required, Validators.email]],
    })

    onSubmitReactFrom(){
      this.myForm["submitted"] = true;
      if(this.myForm.valid){
      console.log(this.myForm.value)
      }
    }

  
=> Passing content form parent to child 
    parent component
    <app-child>
      <element1></element1>
      <element2></element2>
    </app-child>

    child component 
    <ng-content></ng-content>

=> life cycle hook 
  Angular automatically executes some method in our component class at each milestone to the life cycle.
  these are called lifecycle hooks.

  1.  ngOnChanges 
    Execute automatically when we have received one or more values into input properties. that are decorated by @Input decorator. 
    It will not execute when there are no input properties. Use for examine incoming values and want some changes in incoming values.

  2. OnInit 
    Execute automatically after loading values into data-bound properties of the components. 
    Use to call service to get initial data form the database.

  3. ngDoCheck 
    Execute every time when change detection process start in the component.
    Execute when an event occur, before change "detection process". Use to identify whether change detection process occur or not.
    Use for third party control.
  
  4. ngAfterContentInit
    Execute only once in a lifetime of the components after initializing the content that is supply by the parent component and rendered
    using "ng-content" tag. 

  5. ngAfterContentChecked 
    Execute every time after completion of change detection process to the content.

  6. ngAfterViewInit 
    Execute only once after initializing all the elements in the template of the component.

  7. ngAfterViewChecked 
    Execute every time after completion fo change detection process of the template. 

  8. ngOnDestroy 
    Execute before destroying (deleting) the component object deleted from memory. [ when the route has changed. ]
















  















Injector, provider, how to get service? => services get injected inside our component

=> Injector 
Injectors are data structures that store instructions detailing where and how services form. 
@Injectable is a decorator in Angular framework, it allows the service to be injected in Components or other service.

=> provider 
  A provider is an object declared to Angular so that it can be injected in the constructor of your components, directives and other classes instantiated by Angular.

  => What is the use of providers in Angular?
    Providers are classes that create and manage service objects the first time that Angular needs to resolve a dependency. Providers is used to register the classes to an angular module as a service

Interceptors => before calling the api add some logic

Change detection => any time any event occur its run like scroll, click, press any key.

=> View encapsulation =>  use for styling
    ViewEncapsulation.ShadowDom => don't effect others
    ViewEncapsulation.none => global style
    ViewEncapsulation.Emulated => children will not get any style form its parent

=> ng-template 
  It is pre-defined special element. which may contain one more html element.
=> ngModule 
=> ng Content
  Ng content use as a projection to take Html into another component with <ng-content></ng-content> user can present there own content.
  ex: <app-home> Content </app-home>

=> template statement
  Template statement is response on event raise by target like element, component or a directive.
=> View child     
=> decorator
    . Input 
    . Output 
=> Event emitter 
=> template variable 
=> Interface 
=> Dependencies injection 

=> Typescript 
  Typescript is super set of javascript. That means any valid javascript code also valid typescript code. Its added type to the javascript. 

=> life cycle hook 
  In angular, every component has lifecycle. Angular create and render these component and also destroy them before removing from the DOM. This is achieve with the help of lifecycle hook.

=> What is server rendering in angular?
  Angular Universal generates static application pages on the server through a process called server-side rendering
  Server-side rendering means using a server to generate HTML from JavaScript modules in response to a URL request. 
  Server side Rendering (SSR) is a modern technique to convert a Single Page Application (SPA) running in the browser into a server based application.

=> Slice pipe 
  Slice pipe take two parameter startIndex and endIndex and it get part of string, between startIndex to endIndex.

=> Pure pipe
  All the pipes are by default pure pipe. Pure pipe is faster then impure pipe.
  Pure pipe doesn't re-execute, in case of any changes to the object properties.
  Pure pipe doesn't re-execute, in case of any elements added to removed in the array.
  A pure pipe is only called when Angular detects a change in the value or the parameters passed to a pipe

=> Impure pipe 
  The pipe is executed on every change detection. It re-execute automatically if any value or element added or remove.
  impure pipe is called for every change detection cycle no matter whether the value or parameter(s) changes.
    @Pipe {
      name: 'pipeName',
      pure: false
    }

=> Why Async pipe is impure?
  Async is an example of an impure pipe. It is always checking for new input data.
  The async pipe subscribes to an Observable or Promise and returns the latest value it has emitted. When a new value is emitted, the async pipe marks the component to be checked for changes. When the component gets destroyed, the async pipe unsubscribes automatically to avoid potential memory leaks.  

=> Subject
  The subjects are also observers because they can subscribe to another observable and get value from it.

=> subject and BehaviorSubject?
  A BehaviorSubject holds one value (so we actually need to initialize a default value). When it is subscribed it emits that value immediately. A Subject on the other hand, does not hold a value.
  In Subject, the subscribers will only receive the upcoming value. In BehaviorSubject, the subscribers will receive the previous value and also upcoming value.

=> What is active route?
    An active route is a route that is selected as the best path. Inactive routes are not displayed

=> What is Auth guard in Angular?
  AuthGuard is used to protect the routes from unauthorized access in angular.

=> safe navigation 
  The Safe Navigation Operator is also known as the "Elvis Operator". This operator is very useful to protect against null and undefined values in property paths.




=> type of form why they use 
=> life cycle hook 
=> join compiler or avoid compiler  
=> Activated route 
=> Router state 
=> Synchronous and asynchronous



=> Block element modifier 
=> Closure 
=> lexical scope 
=> Pure function 
=> Temporal dead zone 
=> IIFE function 
=> Promises 
=> Status of the Promises 
=> call back function 
=> generator function 
=> Template literal 
=> Arrow distrusting



pass data on navigation =>
post man 
find -> url?=finderText



----------------------------------------------------  
Angular Material 
=> install angular material 
  ng add @angular/material


=> Close dialog box popup
  import { MatDialogRef } from '@angular/material/dialog';

  export class YourDialog {
  constructor(public dialogRef: MatDialogRef<YourDialogComponent>) { }
    closeDialog() {
      this.dialogRef.close('Pizza!');
    }
  }

=> Open the dialog box popup on event and pass the data 
   onEdit(data: any){
    this.dialog.open(DialogComponent, {
      width: "60%",
      data: data // passing data
    });
  }

  -> set the data on the form
    .ts 
    import MAT_DIALOG_DATA
    @Inject (MAT_DIALOG_DATA) public editData: any  => add on constructor
    ngOnInit => set the data 
      this.productForm.controls['productName'].setValue(this.editData.productName);