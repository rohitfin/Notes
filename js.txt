=> jQuery
	=>  Selectors 
		$("*"), $(this), $("p:first"), $("ul li:first-child"),$("[href]"),$("a[target='_blank']"), $(":button"), $("tr:even"), $("tr:odd"), $("ul li:eq(3)"), 
		$("input:not(:empty)"),$(":contains('Hello')"), $("div:has(p)"),$("ul li:gt(3)") [ greater than 3], $("ul li:lt(3)") [ less than 3],	

	=> Events	 
		Mouse Events -  click, dblclick, mouseenter, mouseleave	
		Keyboard Events	- keypress, keydown, keyup	
		Form Events - submit, change, focus, blur 	
		Document/Window Events - load, resize, scroll, unload

		$(selector).event(function(){ // action goes here!!  });  // element.addEventListener("click", FUNCTION__NAME);
		$(selector).on("event", function(){ // action goes here!! });
		$(document).on("event", "selector" function(){ // action goes here!! });
		$(document).on("click", ".btn", functionName); 

		$(selector).on({
			event: function(){  // action goes here!! },
			event: function(){  // action goes here!! },
			event: function(){  // action goes here!! }
		});
		
	=>  HTML
		* Get & Set Content - text(), html(), and val()	
	=> Get  the value of an attribute:
		$(selector).attr("attribute")   // document.querySelector('#IDNAME')
		$('input[type="radio"]:checked').val()
		$(select option:selected).val()

	=> Set the attribute and value:
		$(selector).attr("attribute","value")
		$(selector).prop("checked","checked")
		$('.cls').prop("checked",false)

		=> Set multiple attributes and values:
			$(selector).attr({"attribute":"value", "attribute":"value",...});

	=> Methods 
	addClass(), removeClass(), toggleClass(), on, append(), prepend(), after(), before(), remove(), empty(), clone(), 
	replaceWith(), replaceAll(), wrap(), Unwrap(), wrapAll(), wrapInner(), width(), innerWidth(), outerWidth(), position(), 
	offset(), scrollTop(), scrollLeft(), has(), each(), hasClass(), 	

		remove() - Removes the selected element (and its child elements)
		empty() - Removes the child elements from the selected element
		position()- exact location [only top, and left location gives]
		offset()- start location [only top, and left location gives]

		$(selector).addClass("className");
		$(selector).append("Some appended text.");
		$(selector).has(selector-children).css("color","red"); or $("selector:has(selector-children)").css("border", "solid red");
		$("<h2>Hello world!</h2>").replaceAll("p");

	=> Chaining method
		$(selector).css('color','red').slideUp().slideDown();

	=> css() Method - 
		css("propertyname","value");
		css({"propertyname":"value","propertyname":"value",...});

	=> Effects 
		hide(), show(), toggle(speed,callback), fadeIn(), fadeOut(), fadeToggle(), fadeTo(), slideDown(), slideUp(), slideToggle() 	
		
		$(selector).hide(speed,callback);
		
	=> Animation Effects - $(selector).animate({params},speed,callback);	
		.selector {position: absolute} // important for animate();
		$(selector).animate({
			left: "px",
			opacity: "px",
			width: "px",
			height: "px"
		},3000);
		
		Stop Animations - $(selector).stop();	

	=> Traversing
		<div id="main-outer">
			<ul id="outer">
				<li id="inner">
					<span> </span>	
				</li>
				<li id="inner">
					<b> </b>
				</li>
			</ul>
		</div>

		* The <div> element is the parent of <ul>, and an ancestor of everything inside of it
		* The <span> element is a child of the left <li> and a descendant of <ul> and <div>
		* The two <li> elements are siblings (they share the same parent)
		* jQuery Traversing - Ancestors :- parent(), parents(), parentsUntil(), closest(), offsetParent()

		* Traversing - Ancestors
			$("span").parent();
			$("span").parents("ul");	[kha tak]
			$("span").parentsUntil("div"); [kha tak]

		* Traversing - Descendants :- children(), find()
			$("li").children().css("color","red");
			$('li').children('b').css('font-weight','bold');

		* Traversing - Siblings :-  siblings(), next(), nextAll(), nextUntil(), prev(), prevAll(), prevUntil()
			$("h2").nextUntil("h6");

		* Traversing - Filtering :- first(), last(), eq(), filter() and not(), slice()
				$(selector).filter(".intro");  [other than .intro]

=> AJAX 
    AJAX ( asynchronous JavaScript and XMl ) is not a language, but it is a concept, Which is used to "send background request to server" 
    and also "get background response from server", without refreshing (reloading) the web page in the browser.
    status code 200 - success and status code 404/500 - error
    
    Get - Used to retrieve / search data from server.
    Post - Used to insert data to server.
    Put - Used to update data on server.
    Delete - Used to delete data from server.

    $(function() {
        var product = $("#product_list");
        product.length && initProduct();
    });

    var _m = _m || {}, _apiName = "APIName"

    _m.Ajax = function(methodName, apiUrl, dataType, requestData, contentType, asyncBoolean) {
        return void 0 === o && (o = !0),
        $.ajax({
            type: methodName,
            url: apiUrl,
            dataType: dataType,
            async: asyncBoolean,
            data: requestData,
            contentType: contentType,
            success: function(e) {},
            error: function(e, t) {
                console.log("error->" + apiUrl + " | Error->", e, t)
            }
        })
    }

    function initProduct() {
        var postData = { isActive = true; }
        _m.Ajax("POST", "api_path_url", "json", JSON.stringify({ postData }), "application/json; charset=utf-8", false).then(response=>{
            console.log(response);
        })
    }
  

	JSON in table format in console
	console.table(data);	

  	<!-- second Way formate  start -->
        <div class="template" style="display: none">
            <div class="JSON-child-Result-2">
                <div class="card" >
                    <img  class="pok-img card-img-top p-2" src="__imagURL__" alt="Pok Name">
                    <div class="card-body">
                       <h5 class="pok-title card-title">__name__</h5>
                       <ul class="types">
                           __list__
                       </ul>
                   </div>
               </div>
            </div>
        </div>

	var imgurl= res.sprites.other.dream_world.front_default;
     var name = res.name;
     var list = '';
    
     for(var i = 0; i < res.types.length; i++){
         list += '<li>' + res.types[i].type.name + '</li>'
     }
				
	$('#img1').attr('src',imgurl);
    $('#name1').html(name);
    $('#list1').html(list);

    // second way
     var template = $('.template .JSON-child-Result-2').html()
     var _html = template.replace('__imagURL__',imgurl)
                        .replace('__name__',name)
                        .replace('__list__',list);
    $('#JSON-child-Result-2').append(_html);

	<!-- second Way formate  end -->


    <!--  third way  -->
       var aa =`<div class="card" >
       <img  class="pok-img card-img-top p-2" src="${imgurl}" alt="Pok Name">
       <div class="card-body">
          <h5 class="pok-title card-title">${name}</h5>
          <ul class="types">
          ${list}
          </ul>
       </div>
       </div>`;
    <!-- End third way  -->

    $('#JSON-child-Result-3').append(aa);

=> AJAX Method
	$.ajax({
			url: "api_url",
			type:"post",
			data: {limit:10},
			dataType: 'json',
			success: function(result){
				console.log(result);
			},
			error: function(error){
				console.log(error);
			}
	});

=> Fetch Method
	fetch( 'fetch url', {
		method : 'POST ',
		header : { 
			'Accept' : ' application/json, plan/json, / ',
			' Content-type' : ' application/json '
		},
		body : JSON.stringify( { title: title, body: desc })
	} )
	.then( (res) => res.json( ) )
	.then ( ( data ) => { console.log ( data ) } )
	.catch( ( error ) => { console.log ( error ) } );

=> JavaScript -----------------------
  -> defer keyword for default .js file
  <script type="module" defer src="myScript.js"></script>


event.preventDefault()

The event.preventDefault() method stops the default action of an element from happening.
Prevent a submit button from submitting a form
Prevent a link from following the URL

=> Selectors
	document.getElementById('selectorName')
	document.getElementsByTagName('selectorName')
	document.getElementsByClassName('selectorName')
	document.querySelector('selectorName')
	document.querySelectorAll('selectorName')

=> get and set the data
	element.innerText
	element.innerHTML =  new html content

	element.style.property = new style 	
		[
			document.getElementById("selector").style.color = "blue";
			document.style.cssFloat = "right";
			document.querySelector('selector').style.cssText = 'padding: 10px 20px;color: white'; 
		]

	element.setAttribute(attribute, value)  
		[
			document.getElementById("myImage").src = "landscape.jpg";
					OR 	
			var sel = document.getElementById("myImage");
			sel.src = '../images/img.jpg';
			sel.title = 'this is custom title';
		]

	element.getAttribute(attribute)    
		[
			document.getElementById("myImage").getAttribute('src');
				OR
			var sel = document.getElementById("myImage");
			console.log(sel.src);
			console.log(sel.title);
		]
	

	** form get value
		var name = document.querySelector('.input');
		var sel = document.querySelector('select');
		var selected = document.querySelector('select option:checked');
		var gender = document.querySelector('input[type="radio"]:checked');
		var checkboxList = document.querySelectorAll('input[type="checkbox"]:checked');
		var checkboxValue = [];
		checkboxList.forEach(function(checked){
			checkboxValue.push(checked.value)
		})
		OR
		var sel = $('select option').filter(':selected').val();
		var sel = $('select option:selected').val();
		var checkbox = [];
			$('input[type="checkbox"]:checked').each(function(){
			var val = $(this).val();
			checkbox.push(val);
			});

	* selector.setAttribute('checked', 'true'); 
			
	** select option
		var sel = document.getElementById('selector').selectedIndex;
		var res = document.getElementsByTagName('option')[sel].value;
			OR
		var sel = document.getElementById('ed');
		var res = sel.options[sel.selectedIndex].value;
		console.log(res);
			OR
		var res = document.getElementById('selector').options[document.getElementById('selector').selectedIndex].text;
		console.log(res);

	** radio button
		var gender = document.getElementsByName('gender');
		var genderValue = '';
		for(var i = 0; i < gender.length; i++){
			if(gender[i].checked){
				genderValue += gender[i].value;
			}
		}

	** toggle, add and remove class
		[	var idSelector = document.getElementById('selector');
			var QuerySelector = document.querySelector('selector');

			.classList.add('NEW__CLASS') ---> ADDING NEW CLASS 
			.className = 'NEW__CLASS' ---> ADDING NEW CLASS => first remove classes than add new class so don't use
			.classList.toggle('NEW__CLASS') ---> toggle  CLASS
			.classList.remove('NEW__CLASS') ---> remove  CLASS
		]
	
=>  EventListener, removeEventListener() ---> attachEvent(), detachEvent()
	element.addEventListener("click", FUNCTION__NAME);
	element.addEventListener("click", function() {	alert("Hello World!");  });
	element.addEventListener("click", function(){ myFunction(p1, p2); });
	
=> DOM 
	-------- document
	URL, .domain, .body, .forms, .head, .images, .links, .title, 
	createAttribute(), .createElement(), createEvent(), createTextNode(), .designMode

	document.designMode = "on"; --> editable or not
	document.doctype.name 
	document.documentMode;

	.value, .innerHTML, #SELECT__OPTION.options[#SELECT__OPTION.selectedIndex].text, offsetWidth, .offsetHeight, 
	screen.width, screen.height, 
	screen.availWidth, screen.availHeight, innerWidth, innerHeight, window.open, window.close

	.addEventListener, .getAttribute(), innerHTML, innerText, querySelector, querySelectorAll, 
	.appendChild(), classList.add(), classList.remove(), .className, .firstChild, .lastChild, firstElementChild, 
	lastElementChild, insertBefore, outerHTML, remove, removeAttribute, removeChild, removeEventListener, replaceChild, tagName, 
	title, dataset, textContent, createTextNode, createElement

=> Event 
	mouseover, mouseout, change, click, dblclick, keydown, load, submit, select,
	keypress, mousemove, mouseleave, mouseenter, mousedown, mouseup, focusin, focusout
	keypress, mousemove, mouseleave, mouseenter, mousedown, mouseup, focusin, focusout

   	<button onclick="myFunction()">Click me</button>
	<button type="button" onclick="document.getElementById('IDNAME').style.color = 'red'">Click Me!</button>

* initialization or starter or starting point
* condition for when our loop should end
* increment or decrement || continues up or down

* loop work on the only true condition, when loop condition is false loop will stop working.

  var -> function scope.
  let -> block scope
  const -> block scope
  
=> Primitive and non primitive.
  Primitive : store single values. just a value (copied when assigned),  Number, String, Boolean, Undefined, Null
  Non-Primitive : reference to a value (shared when assigned),  Object, Array, function

=> Let, const temporal DEAD Zone 
    -> let and const are hoisted. we cant use them before initialization is result of "temporal dead zone".
    -> js use diff memory than global execution context to store let and cost. which is reason behind "temporal dead zone"
    -> level of strictness ... var<<let<<const.
    -> var //no temporal dead zone, can redeclare and re-initialize, stored in GES
        let //use TDZ, can't re-declare, can re-initialize, stored in separate memory
        const //use TDZ, can't re-declare, can't re-initialize, stored in separate memory
    -> syntax error is similar to compile error. while type and reference error falls under run time error.
    -> syntax error ... violation of JS syntax
        type error ...  while trying to re-initialize const variable
        reference error ... while trying to access variable which is not there in global memory.

=> Block scope
    Block :- It is used to combine multiple statement into one statement so that we can use it at those places where javascript expects to have single statement.
    Scope :- scope of a variable or a function is the place where these are accessible.
    Block scope :-  The variables and function present within the scope of a block section. And block follows the lexical scope chain pattern while accessing the variable.
    Shadowing :-  Providing same name to the variable as of those variable which are present in outer scope.

    ex : {
        var a = 10;
        let b = 20;
        const c = 30;
    }

    shadowing -> 
        var a = 20; let b = 10; const c = 30;
        {
            let a = 200;
            var b = 100;
            const c = 300;
        }

=> Hoisting 
    Hoisting means try to access variable or function before they are declared.
    var - undefined
    let/ const - reference error 
    function statement/ function declaration - are hoisted
    function expression - error

=> Temporal Dead Zone
    Temporal Dead zone means variable form the hoisting till the initialization that phase is called temporal dead zone.

=> Scope Chain 
    When javascript execute a function and we reference a variables: it first look inside the current function scope. If it does not find it, it look one level up, in the outer scope. It keep going until it reaches the global scope. If it still does not find it throw reference error.

=> Lexical Scope 
    Lexical scope means a function can access variables from the place where it was written, not from where it is called. When function is defined it remember its environment(variable/function). This remember environment is become lexical environment.

=> function statement / function declaration 
    function a(){}

=> function expression  (function is like a value)
    var b = function(){}

=> Named function expression
    var a = function sum(){ }

=> First Class Functions -> 
    The ability to to use functions as values and which can be passed as arguments to another function, and also can be returned from a functions.

=> Anonymous function ->
     A function without a name is called anonymous function. It used as values.

=> First class function 
    Assigned to variables, passed as an arguments, or returned from other function, stored in object or array.

=> Higher order function
    function takes another function as an argument or return a function.
    or
    A higher order function is a function that takes one or more functions as arguments, or returns a function as its result.
    
=> Pure function 
  Pure function is a function that always return the same output for the same input and has no side effects. Easier to use, test, debug and reuse.

  function add(a, b) {
    return a + b;
  }

  Impure -> It modifies an external variables. It doesn't always return the same result. 
  let count = 0;
  function increment() {
    count++;
  }

=> IIFE function - Runs as soon as it is defined. immediately invoke after it’s 
    defined without needing to explicitly call It create private scope and useful 
    in module patterns and initialization code.

    (function() {
      console.log("IIFE runs immediately!");
    })();

=> generator function - reusable block of code
    To avoid repeating code
    To break complex logic into smaller, manageable parts
    To improve readability and maintainability

=> different between normal function and arrow function.
    A normal function in JavaScript is defined using the function keyword. 
    It has its own this, arguments object, and can be used as a constructor.

    An arrow function is a shorter syntax introduced in ES6. It does not have its own this, arguments, or constructor, and is often used for writing concise functions.

=> Template literal 
    that provide a cleaner and more powerful way to work with strings. They were introduced in ES6
    String Interpolation:
    let a = 5;
    let b = 10;
    let sum = `The sum of ${a} and ${b} is ${a + b}.`;

=> substring() - between two indices (positions), from a string, and returns the substring. you have to enter start position or end position.
  let text = "Hello world!";
  let result = text.substring(1); // ello world!
  let result = text.substring(1, 4); // ell

=> lastIndexOf() - returns the index (position) of the last occurrence of a specified value in a string, returns -1 if the value is not found, is case sensitive.
  let text = "Hello planet earth, you are a great planet.";
  let result = text.lastIndexOf("Planet");

=> search() - searches a string for a value and returns the position of the first match, returns -1 if the value is not found, is case sensitive.
  let text = "Mr. Blue has a blue house"
  let position = text.search("Blue"); // 4

=> slice -> does not modify the original array or string; it returns a new one.
  array.slice(start, end)
  array.slice(-1) -> return last value of the array.
  array.slice(2, -1) -> It return values form 2 to 2nd last value for array.
  array.slice(2, 4) -> It return values form 2 position to before 3th position values. That means end value se ek kam tak.

=> splice => Modify the original array. It returns a new one.
  array.splice(start, end);
  arr.splice(-1) -> return last value of the array.
  array.splice(2, 0, 22) -> (position, number of value going to replace, New value) - Add the value of 22 after 2 position value.
  array.splice(3, 2, 13) -> (position, number of values going to replace, new value) - replace the 2 values form 3 position with 13. 

=> toReversed() -> does not modify the original array or string; it returns a new one.
  array.toReversed();

=> toSpliced() -> does not modify the original array. It allows for both adding and removing elements in one call.
  array.toSpliced(start, deleteCount, ...items) 
    start: The index at which to start changing the array.
    deleteCount: The number of elements to remove from the array (optional).
    ...items: The elements to add to the array at the specified index (optional).
  array.toSpliced(1, 1, 'newValue');

=> includes() -> does not modify the original array. It return boolean value if match the value return true else false. is case-sensitive
  array.includes(value, fromIndex);
    value: The value to search for in the array.
    fromIndex: The position in the array to start the search (optional). If negative, it searches from that position counting backward.

  string.includes(searchString, position);
    searchString: The substring to search for within the string.
    position: The position in the string to start the search (optional). Default is 0.

    const message = "Hello, world!";
    console.log(message.includes("o", 5));  // true (starts searching from index 5)

=> Find() -> return first element once satisfied if not match return undefined, does not effect original array. Use for search.
    array.find(ele, ind, arr)

=> some() -> return boolean value once satisfied return true else false. Does Not Modify the Original Array
    array.some(ele, ind, arr)

=> every() -> return boolean value, method stops checking as soon as it finds an element that does not meet the condition. Does Not Modify the Original Array   
    every.some(ele, ind, arr)

=> flat() -> returns a new array and does not modify original array. it makes nested arrays into a single-level array. concat ting nested array.
    array.flat([depth]) -> The depth level specifying how deep a nested array structure should be flattened. The default is 1. 
    If we don't know the count of nested array then we can pass "Infinity".
    const nestedArray = [1, 2, [3, 4]]; const flatArray = nestedArray.flat(); // Output: [1, 2, 3, 4]
    const moreNestedArray = [1, [2, [3, [4]]]]; const flatDefault = moreNestedArray.flat(); // Output: [1, 2, [3, [4]]]
    const moreNestedArray = [1, [2, [3, [4]]]]; const flatDefault = moreNestedArray.flat(2); // Output: [1, 2, 3, 4]
    const infiniteNestedArray = [1, [2, [3, [4, [5]]]]]; const flatInfinite = infiniteNestedArray.flat(Infinity); // Output: [1, 2, 3, 4, 5]

=> flatMap() -> return new array, does not modify original array. It is combination of map() and flat() method. 
    It's great for working with nested structures, particularly when we want to extract or manipulate elements from arrays of objects.
    get the single value from each element of the array of object into a single array. Ex - form nested arrayOfObject only need userId.
    array.flatMap();

=> Shallow Copy -> It create the new reference of the array or object but not for nested structures. Modifications does not 
  effect on top level. Modifications affect both the copy and the if nested structure.
  If we made changes on the top level it does not affect the original array or object but if change the nested structure it effect
  the original as well as reference. 
    const originalArray = [1, 2, { a: 3 }];
    const shallowCopyArray = originalArray.slice(); or [...originalArray];
    
    const originalObject = { a: 1, b: 2 };
    const shallowCopyObject = Object.assign({}, originalObject);

=> Deep Copy -> do not affect the original array or object. Creates copies of all nested objects. Modifications to the copy do not affect the original.
    const original = { a: 1, b: { c: 2 } };
    const deepCopy = JSON.parse(JSON.stringify(original));
    let clone = structuredClone(value);

=> Spread operator -> using for shallow copy or merging array or object. Take element and replace them individually.
    const obj1 = { name: 'John', age: 30 };
    const obj2 = { country: 'USA' };
    // object literals
    const merged = { ...obj1, ...obj2 }; // Output: { name: 'John', age: 30, country: 'USA' }
    // Object Destructing
    const newObj = { ...obj1, age: 50 }; // Output: { name: 'John', age: 50 };

=> Rest Operator -> used to collect multiple values into a single variable. Gathers remaining elements into an array. 
    Passing n number of parameter with the help of rest operator(...)
      const numbers = [5, 2, 1, 1];
      function init(...rest){
        console.log(rest); // [ [5, 2, 1, 1] ] -> it return in array
      }
      init(numbers);

      const arr = [1, 2, 3, 4, 5];
      // Array Destructuring
      const [first, second, ...rest] = arr;
      console.log( first, second, rest); //Output: 1, 2, [3, 4, 5];

 => Array Destructuring -> extracting values from arrays and objects. Rest operator (...) is used to gather remaining elements into a new array.
    we can provide default values for variables in case an element in the array or object is undefined.
    const numbers = [10, 20];
    const [x, y = 30, z = 40] = numbers; // default value y=30, z = 40
    const person = { name: 'mike', age: 23 }
    You can rename the variables during destructuring.
    const { name: personName, age: personAge } = person; // renaming keys name or variables

=> Object.entries() : Converting object into array with looping. It segregate key and value of the object.
    let obj = {name: 'mike', age: 23}
    for(const [key, value] of Object.entries(obj) ){ }
    
=> || operator is the logical OR operator. It evaluates expressions from left to right and returns the first truthy value it encounters. 
    If all values are falsy, it returns the last value.
    let value = userInput || defaultValue; // if userInput is falsy, value gets defaultValue

=> Recursion :  a function calls itself repeatedly. A recursive function generally has two main parts:
    Base case: The condition that stops the recursion (prevents an infinite loop).
    Recursive case: The part where the function calls itself
      function factorial(n) {
      if (n === 0 || n === 1) {
        return 1;
      } else {
        return n * factorial(n - 1);
      }
    }
    console.log(factorial(5));

=> Async/ wait : handle asynchronous code,  An async function always returns a promise, and inside that function, we can use the await keyword.
    await: This keyword is used inside an async function to pause the execution of the function until a promise is resolved. 
    The result of the promise is returned once it's resolved. If the promise is rejected, an error is thrown.
    errors handling using try/catch blocks.

=> Promise handling asynchronous operations like fetching data from api.
    Pending: The promise is still in progress, the operation is not finished.
    Fulfilled (Resolved): The asynchronous operation completed successfully.
    Rejected: The asynchronous operation failed, and an error occurred.

    [Promise chaining, Return Values or Promises, Error Handling, Promise.all, Promise.allSettled, Promise.any, finally ]
    Promise Chaining: Allows handling multiple asynchronous operations sequentially.
    Promise chaining in JavaScript is a technique where multiple promises are executed in sequence. Each promise in the chain gets executed 
    after the previous one has resolved, allowing for smooth handling of asynchronous code. 
    
      fnFetchApi(){
        return new Promise((resolve, reject)=>{
          setTimeout(()={
            if(true){
              resolve("Resolved");
            }else {
              reject("Reject");
            }
          }, 3000)
        })
      }

      fnFetchApi().then(()=>{
      }).then(()=>{
      }).catch(()=>{
      }).then(()=>{
      }).catch(()=>{
      })

      async function promiseFun() {
        try {
          let one = await promiseOne();
          let two = await promiseTwo(one);
          let three = await promiseThree(two);
        } catch (e) {
          console.log("Something went wrong!");
        }
      }
      promiseFun();

    Promise.all() => Waits for all promises to be fulfilled. If any fail, the whole operation fails. accept an array of promise return single array of promise. If any promise rejected then reject the promise. 
      let p1 = Promise.resolve(3);
      let p2 = Promise.reject(4);
      let p3 = Promise.resolve(5);
      
      Promise.all([p1, p2, p3]).then(function(res){
        console.log(res);
      }).catch(function(err){
        console.log(err);
      })

    Promise.allSettled() => Waits for all promises to settle (either resolve or reject). accept an array of promise return each value in single array of promise. wait for all the promise to executed.
      Promise.allSettled([p1, p2, p3]).then(results => {
      console.log(results);
      // Output:
      // [
      //   { status: 'fulfilled', value: 3 },
      //   { status: 'rejected', reason: 'Failed' },
      //   { status: 'fulfilled', value: 5 }
      // ]
      });

    Promise.any() => Resolves as soon as any promise resolves. Only rejects if all promises reject.  accept an array of promise return a promise as soon as promise resolve. If all the promise rejected then return reject.

    Promise.race() => Resolves/rejects as soon as one of the promises settles. accept an array of promise return a promise as soon as first promise resolve or reject.
      finally() => When all the promise executed then finally work.
      promise.then(()=>{
      }).then(()=>{
      }).catch(()=>{
      }).finally(()={
      console.log('Finally Promise is executed');
      })

=> call(), apply() and bind()
    call() => passing arguments individually. function is invoked immediately when call() is called.
    greet.call(referenceObject, arg1, arg2, ...)

    apply() => it takes an array (or array-like object) of arguments. function is invoked immediately when call() is called.
    greet.apply(referenceObject, [arg1, arg2, ...])

    bind()=> The function is not invoked immediately. Instead, it returns a new function, and you can call it later. in simple word take a copy of
      of function, store on variable and call when use.
    const boundFunction = greet.bind(referenceObject, arg1, arg2, ...)

=> Event bubbling and capturing (tripling down)
    Event bubbling -> Event start at the target element and then bubble up to the root.

    Capturing -> Event start from the top (document) and trickle down to the target element.

    we can stop event bubbling and capturing with stopPropagation
    e.stopPropagation();
    e.stopImmediatePropagation()

    ex: 
    <div id="grandParent">
        <div id="parent">
            <div id='child1'></div>
            <div id='child2'></div>
            <div id='child3'></div>
            <div id='child4'></div>
            <div id='child5'></div>
        </div>
    </div>
    document.querySelector('#grandParent').addEventListener('click', (e)=>{
        e.stopPropagation();
    }, true) // => true means capturing, false means bubbling (it by Default)

=> Event Delegation
    It is a technique where we use a single event listener on a parent element instead of adding multiple event listeners to each child element.
    or 
    It's a technique where a single event listener is attached to a parent element, rather than attaching separate listeners to each child element.

     document.querySelector('#grandParent').addEventListener('click', (e)=>{
        if(e.target.id){
            console.log(`${e.target.id} clicked`);
        }
    })

=> Callback
    1. Function that is passed on as argument to another function is called callback function.
    2. setTimeout helps turn JS which is single threaded and synchronous into asynchronous.
    3. Event listeners can also invoke closures with scope.
    4. Event listeners consume a lot of memory which can potentially slow down the website therefore it is good practice to remove if it is not used.
    
    A callback is a function passed as an argument to another function and is executed later, usually after some asynchronous task.
    function init(callback) {
      setTimeout(function() {
        callback('Result of async operation');
      }, 1000);
    }
    init(function(result) {
      console.log('Received:', result);
    });
    
=> Currying
    Currying is a technique in javascript where a function is transformed into a sequence of functions, each taking a single argument.
    or 
    A function with multiple argument is transformed into a series of functions, each taking a single argument.

    function add(a){
        return function (b){
            return a + b;
        }
    }
    let total = add(5)(5) // output = 10;

=> Closure
    Closure is a function which is surrounded by its lexical environment. It's remember there reference memory location not values. in closure inner function can access outside of its variable which is present there parent environments.

    Uses 
        - User for data encapsulation and data hiding
        - Module design pattern
        - currying 
        - function like once - can run once
        - memoize
        - Maintaining state in async world
        - setTimeouts

=> Debouncing and throttling
    Debouncing -> Function is called only after a creation period of time. If the event keeps triggering, the timer resets each time.

    Debouncing makes sure a function only runs after the user stops performing an action for a certain amount of time.

    Trigger time - after user stops
    use case - typing, search box
    Purpose - not called too frequently or Delay function call until idle (Nothing is happening for a certain period of time.)
    
        <input type="text" id="searchInput">

        const debouncing = function(fn, d){
          let timer;
          return function(...args){
            clearTimeout(timer);
            timer = setTimeout(()=>{
              fn.apply(this, args);
            }, d)
          }
        }

        function onSearch(event){
          console.log(' Search - ' + event.target.value);
        }

        document.getElementById('searchInput').addEventListener('keyup', debouncing(onSearch, 500))

    Throttling -> Function is called at most once in a specific time interval, no matter how many times the event occurs.
    Trigger time - At fixed intervals
    User case - scrolling and re-sizing
    Purpose - Limit how often function is called
        
      <input type="text" id="searchInput">
      const throttle = function (func, limit) {
        let isThrottle = false;
        return function (...args) {
          if (!isThrottle) {
            func.apply(this, args);
            isThrottle = true;
            setTimeout(() => {
              isThrottle = false;
            }, limit)
          }
        }
      }
      function onInput(event){
        console.log('Throttled Input : '+ event.target.value);
      }
      const throttledInput = throttle(onInput, 1000);
      document.getElementById('searchInput').addEventListener('keyup', throttledInput)
    
=> Event Loop
    The Event  Loop pushes the "queue" into the Call Stack only when the Call Stack is empty (i.e. the global execution context has been pushed off the call stack).
    The order in which the Event Loop works is:
    1. Call Stack
    2. Micro task Queue
    3. Callback Queue

    Call Stack: => The call stack is a data structure that keeps track of the function calls in your code.  the last function that gets pushed onto the stack is the first one to be popped off when the function completes.

    Callback Queue (Task Queue) =>  holds tasks (callbacks or events) that are ready to be executed. These tasks usually come from asynchronous operations, such as DOM events, HTTP requests, or timers.

    Event Loop =>  The event loop is responsible for continuously checking the call stack and the callback queue. If the call stack is empty, the event loop takes the first task from the callback queue and pushes it onto the call stack for execution.

    Microtask Queue: => The microtask queue holds tasks that are also ready to be executed but has a higher priority than the callback queue. Microtasks are usually scheduled by JavaScript promises, mutation observers

    => Micro and Macro task
      Microtasks are scheduled via:
        Promise.then() / Promise.catch() / Promise.finally()
        queueMicrotask()
        MutationObserver

      Macrotasks are scheduled via:
        setTimeout()
        setInterval()

=> This keyword
    this is not about where a function is written; it's about how it's called.

    The this keyword is a fundamental part of JavaScript that refers to the context in which a function is executed. It is dynamic and can change depending on how and where a function is called:

    In the global context, this refers to the global object (window in browsers).

    In object methods, this refers to the object the method belongs to.

    In regular functions, this defaults to the global object (in non-strict mode) or undefined (in strict mode).

    In arrow functions, this is lexically bound – it uses this from the surrounding context.
      
    const person = {
        fname: 'Mike',
        lname: 'Tyson',
        fullName: () => {
            console.log(`${this.fname} ${this.lname}`);
        },
        greet: function () {
            setTimeout(() => {
                console.log(this);
            }, 1000);
        },
        arrow: () => {
            setTimeout(() => {
                console.log(this);
            }, 1000);
        },
        print() {
            console.log(this);
        }
    }
    person.arrow();

=> Prototype and Prototype inheritance
    EVERYTHING IN JAVASCRIPT IS AN OBJECT because of prototype

    inheritance in JS => When an object trying to access variables and properties of another object

    prototype is an Object that get attach to function/method/object and this object has some hidden properties

    Whenever we create object/ function/ methods/ array/ variable, these all are attached with some hidden properties, which we call prototype

    _proto_ is reference to prototype ( or it points towards prototype ), if we want to access prototype, we do _proto_

    prototype object has a prototype of its own, and so on until an object is reached with null as its prototype,  this is called prototype chaining

=> reduce method 
	reduce method is combination of filter and map method.

	const numbers = [450, 200, 75, 80, 90];
	const resultSum = numbers.reduce((accumulator, currentElement, index, array) => {
		return accumulator + currentElement;
	}, 0);  // where to start not given so start with accumulator and value2

	var numberList = [10,2,5,67,3,45,];
	var res = numberList.reduce(function(accumulator, element, index, array){ 
	    if(element > 10){
	        accumulator.push(element);
	        return accumulator;
	    }else{
	        return accumulator;
	    }

	},[]); // in array [] formate it will return;
	console.log(res);

=> object
	A collection of name value pairs. key value pairs.object same as array and in object, we can call function.
		const courses = { java: 10, javascript: 55, nodejs: 5, php: 15 };
		* Methods to loop through objects using javascript for...in Loop
			for (const key in courses) {
				.log(`${key}: ${courses[key]}`);
			}	
		* Object.keys() Method - returns an array containing all properties name
		* Object.values() Method -It returns the values of all properties in the object as an array
		* Object.create();
		* Object.assign();

=> Module : 
  A module in JavaScript is a file that encapsulates code and can export and import variables, functions, classes, etc., so they can be used in other files. This helps in organizing, maintaining, and reusing code across a project.

    Each module has its own scope.
    Modules are loaded once (cached).
    Modules can import other modules.

    <script type="module" src="main.js"></script>

    master.js -> file
        export var add = (a, b) => a + b;

    main.js -> file
        import { add } from './index.js';
        let sum = add(2, 5);
        console.log(sum);

=> Constructor functions  
  a constructor function is used to create and initialize objects. Constructors are functions that contain a this keyword.
	If we initialize the constructor its runs. Create Multiple Objects with Constructor Function.

	function Person (name, age, gender) {
		this.name = name,
		this.age = age,
		this.gender = gender,
		this.greet = function () {
			return ('Hi' + ' ' + this.name);
		}
	}
	const person1 = new Person('John', 23, 'male'); // creating objects
	const person2 = new Person('Sam', 25, 'female');
	
	person1.print = function () { // adding method to person1 object
		console.log('hello');
	}

=> Prototype
		In JavaScript, a prototype can be used to add properties and methods to a constructor function.

		// adding property to constructor function
		Person.prototype.status = 'Married';

		// prototype value of Person
		console.log(Person.prototype);

		// inheriting the property from prototype
		console.log(person1.status);
		
		// changing the property value of prototype
		Person.prototype = { status:  'UnMarried'}

=> Inheritance 
	function Human(person_name, person_age, person_gender, month){
		Person.call(this, person_name, person_age, person_gender);
		this.month = month
	}

	// Inherit Prototype 
	Human.prototype = Object.create(Person.prototype);

	// Instantiate Human Object
	const hum1 = new Human('Mike', '22', 'Male', 'March');

	// use Human Constructor
	Human.prototype.constructor = Human;
	
	console.log(hum1);

=> Sub Class 
	class Human extends Person {
		constructor(person_name, person_age, person_gender, month){
			super(person_name, person_age, person_gender); // get parent properties
			this.month = month;
		}
	}

	// Instantiate Human Object
	const hum1 = new Human('Khabib', '22', 'Male', 'Jan');
	hum1.greet();

=> Class 
	Classes is blue print of object. Classes are said to be the “syntactic sugar” of Constructor functions. 

  classes provide a blueprint for creating objects with shared properties and methods.

  => Inheritance : where one class can inherit from another. This allows you to create subclasses that extend the functionality of a base class.

  => Getters, Setters :  which allow you to control how properties of an object are accessed and modified.

  class Person {
      constructor(firstName, lastName) {
          this.fname = firstName,
          this.lname = lastName,
          this.greet = function () {
              console.log(`Hello, I'm ${this.fname} ${this.lname}`);
              }
      }

      static ask(){ // only parent can access this function
          console.log(`How are you ${this.fname} ${this.lname}?`);
      }

      fullName(){
          console.log(`${this.fname} ${this.lname}`);
      }

      get name() {
          return this.fname;
      }

      set changeName(newName) {
          if (newName.length > 0) {
              this.fname = newName;
          } else {
              console.log('Name must not be empty.');
          }
      } 


  }

  const person1 = new Person("Mike", "Tyson");
  console.log(person1);
  // person1.ask(); // child will not able to access
  // Person.ask();
  // console.log(person1.name());
  person1.changeName = "Bruce lee"; // Change name with set operator
  console.log(person1);

=> Objects Linking to Other Objects (OLOO)

	const Human = {
		init (FirstName, LastName) {
			this.firstName = FirstName
			this.lastName = LastName
			this.sayHello = function () {
			console.log(`Hello, I'm ${firstName}`)
			}
			return this
		}
	}

	//const chris = Object.create(Human)
	//chris.init('Chris', 'Coyier');
	// or
	const chris = Object.create(Human).init('Chris', 'Coyier');
	console.log(chris.firstName);

=> web socket
    - One time TCP connection (handshake)
    - Bi-directional messaging
    - Used for realtime applications
    ex- notification (whatsapp)

=> REST API - 
  Representational State Transfer Application Programming Interface

=> graphQL
  GraphQL stands for Graph Query Language. It is a query language for your API and a runtime for executing those queries with your existing data.
  - Flexible Queries: Clients can ask for exactly the data they need—no more, no less.
  - Single endpoint (e.g., /graphql)
  - A unified schema handles all resources.
  - You want to avoid over-fetching or under-fetching
 








=> Garbage Collector
=> OOps concept
=> Memory Management and Garbage Collection, 
=> Memory Optimization, Algorithm and Data Structure
=> How to stop api call, memory leakage







